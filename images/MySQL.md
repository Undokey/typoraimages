[柏码 - 让每一行代码都闪耀智慧的光芒！ (itbaima.net)](https://itbaima.net/document)

# 1. 什么是数据库

数据库是数据管理的有效技术,是由一批数据构成的有序集合,这些数据被存放在结构化的数据表里。数据表之间相互关联,反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。简而言之,我们的数据可以交给数据库来帮助我们进行管理,同时数据库能够为我们提供高效的访问性能。

在JavaSE学习阶段中,我们学习了如何使用文件I/O来将数据保存到本地,这样就可以将一个数据持久地存储在本地,即使程序重新打开,我们也能加载回上一次的数据,但是当我们的数据变得非常多的时候,这样的方式就显得不太方便了。同时我们如果需要查找众多数据的中的某一个,就只能加载到内存再进行查找,这样显然是很难受的！

而数据库就是专门做这事的,我们可以快速查找想要的数据,便捷地插入、修改和删除数据,并且数据库不仅能做这些事,还能提供更多便于管理数据和操作数据的功能！

## 1.1 常见的数据库

常见的数据库有很多种,包括但不限于：

- MySQL - 免费,用的最多的,开源数据库,适用于中小型
- Microsoft SQL Server - 收钱的,但是提供技术支持,适用于Windows Server
- Oracle - 收钱的,大型数据库系统

而我们要学习的是MySQL数据,其实无论学习哪种数据库,SQL语句大部分都是通用的,只有少许语法是不通用的,因此我们只需要学习一种数据库其他的也就差不多都会了。

## 1.2 数据模型

数据模型与现实世界中的模型一样,是对现实世界数据特征的一种抽象。实际上,我们之前学习的类就是对现实世界数据的一种抽象,比如一个学生的特征包括姓名,年龄,年级,学号,专业等,这些特征也称为实体的一种属性,属性具有以下特点：

- 属性不可再分
- 一个实体的属性可以有很多个
- 用于唯一区分不同实体的的属性,称为Key,比如每个同学的学号都是不一样的
- 属性取值可以有一定的约束,比如性别只能是男或是女

实体或是属性之间可以具有一定的联系,比如一个老师可以教很多个学生,而学生相对于老师就是被教授的关系；又比如每个同学都有一个学号与其唯一对应,因此学号和学生之间也有一种联系。而像一个老师教多个学生的联系就是一种一对多的联系（1:n）,而学号唯一对应,就是一种一对一的联系（1:1）；每一个老师不仅可以教多个学生,每一个学生也可以有多个教师,这就是一种多对多的联系（n:m）

MySQL就是一种关系型数据库,通过使用关系型数据库,我们就可以很好地存储这样带有一定联系的数据。

![img](images/W6NHkfmyZCGpJx7.jpg)

通过构建一个ER图,我们就能很好地理清不同数据模型之间的关系和特点。

# 2. 数据库的创建

既然了解了属性和联系,那么我们就来尝试创建一个数据库,并在数据库中添加用于存放数据的表,每一张表都代表一种实体的数据。首先我们要明确,我们需要创建什么样子的表：

- 学生表：用于存放所有学生的数据,学生（学号,姓名,性别）
- 教师表：用于存放所有教师的数据,教师（教师号,姓名）
- 授课表：用于存放教师与学生的授课信息,授课（学号,教师号）

其中,标注下划线的属性,作为Key,用于区别于其他实体数据的唯一标记。

为了理解起来更加轻松,我们从图形界面操作再讲到SQL语句,请不要着急。我们现在通过Navicat或idea自带的数据库客户端来创建一个数据库和上述三个表。

![image-20230703233225728](images/image-20230703233225728.png)

![image-20230703233428090](images/image-20230703233428090.png)

![image-20230703233601760](images/image-20230703233601760.png)

# 3. 数据库的规范化

## 3.1 第一范式(1NF)

第一范式是指数据库的每一列都是不可分割的基本数据项,而下面这样的就存在可分割的情况：

- 学生（姓名,电话号码）

电话号码实际上包括了`家用座机电话`和`移动电话`,因此它可以被拆分为：

- 学生（姓名,座机号码,手机号码）

满足第一范式是关系型数据库最基本的要求！

## 3.2 第二范式(2NF)

第二范式要求表中必须存在主键,且其他的属性必须完全依赖于主键,比如：

- 学生（学号,姓名,性别）

学号是每个学生的唯一标识,每个学生都有着不同的学号,因此此表中存在一个主键,并且每个学生的所有属性都依赖于学号,学号发生改变就代表学生发生改变,姓名和性别都会因此发生改变,所有此表满足第二范式。

## 3.3 第三范式(3NF)

在满足第二范式的情况下,所有的属性都不传递依赖于主键,满足第三范式。

- 学生借书情况（借阅编号,学生学号,书籍编号,书籍名称,书籍作者）

实际上书籍编号依赖于借阅编号,而书籍名称和书籍作者依赖于书籍编号,因此存在传递依赖的情况,我们可以将书籍信息进行单独拆分为另一张表：

- 学生借书情况（借阅编号,学生学号,书籍编号）
- 书籍（书籍编号,书籍名称,书籍作者）

这样就消除了传递依赖,从而满足第三范式。

## 3.4 BCNF

若：

某公司有若干个仓库；
每个仓库只能有一名管理员,一名管理员只能在一个仓库中工作；
一个仓库中可以存放多种物品,一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。

> 那么关系模式 仓库（仓库名,管理员,物品名,数量） 属于哪一级范式？ 
>
> 已知,
>
> 函数依赖集：仓库名 → 管理员,管理员 → 仓库名,（仓库名,物品名）→ 数量
>
> 码：（管理员,物品名）,（仓库名,物品名）
>
> 主属性：仓库名、管理员、物品名
>
> 非主属性：数量
>
>
> 因为 不存在 非主属性 对码的部分函数依赖和传递函数依赖,所以 此关系模式属于3NF。

基于此关系模式的关系（具体的数据）可能如图所示：

![preview](images/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS82OGQwODBkNDM3NzMyYWFkOGNmZTQ1MWI0Mjc4NDlkNl9yLmpwZw.png)



好,既然此关系模式已经属于了 3NF,那么这个关系模式是否存在问题呢？

我们来看以下几种操作：

- 先新增加一个仓库,但尚未存放任何物品,是否可以为该仓库指派管理员？——不可以,因为物品名也是主属性,根据实体完整性的要求,主属性不能为空。

- 某仓库被清空后,需要删除所有与这个仓库相关的物品存放记录,会带来什么问题？——仓库本身与管理员的信息也被随之删除了。
- 如果某仓库更换了管理员,会带来什么问题？——这个仓库有几条物品存放记录,就要修改多少次管理员信息。

从这里我们可以得出结论,在某些特殊情况下,即使关系模式符合 3NF 的要求,仍然存在着插入异常,修改异常与删除异常的问题,仍然不是 ”好“ 的设计。

造成此问题的原因：存在着主属性对于码的部分函数依赖与传递函数依赖。（在此例中就是存在 主属性【仓库名】对于 码【（管理员,物品名）】的部分函数依赖。因为【仓库名】依赖于【管理员】,而不依赖于【物品名】。）

解决办法就是拆分成两个表,要在 3NF 的基础上,消除主属性【仓库名】对于码【（管理员,物品名）】的部分与传递函数依赖。

将原来的仓库（仓库名,管理员,物品名,数量）

修改为：

> 仓库（仓库名,管理员）
> 库存（仓库名,物品名,数量）

这样,之前的插入异常,修改异常与删除异常的问题就被解决了。


# 4. 认识SQL语句

## 4.1 SQL语句分类

结构化查询语言（Structured Query Language）简称SQL,这是一种特殊的语言,它专门用于数据库的操作。每一种数据库都支持SQL,但是他们之间会存在一些细微的差异,因此不同的数据库都存在自己的“方言”。

SQL语句不区分大小写（关键字推荐使用大写）,它支持多行,并且需要使用`;`进行结尾！

SQL也支持注释,通过使用`--`或是`#`来编写注释内容,也可以使用`/*`来进行多行注释。

我们要学习的就是以下四种类型的SQL语言：

- 数据查询语言（Data Query Language,  DQL）基本结构是由SELECT子句,FROM子句,WHERE子句组成的查询块。
- 数据操纵语言（Data Manipulation Language,  DML）是SQL语言中,负责对数据库对象运行数据访问工作的指令集,以INSERT、UPDATE、DELETE三种指令为核心,分别代表插入、更新与删除,是开发以数据为中心的应用程序必定会使用到的指令。
- 数据库定义语言DDL(Data Definition Language),是用于描述数据库中要存储的现实世界实体的语言。
- DCL（Data Control Language）是数据库控制语言。是用来设置或更改数据库用户或角色权限的语句,包括（grant,deny,revoke等）语句。在默认状态下,只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL。

我们平时所说的CRUD其实就是增删改查（Create/Retrieve/Update/Delete）

## 4.2 SQL语句执行顺序

- 执行顺序: from->on->join->where->group by->having->select->distinct->order by->limit

  - 我们先执行from,join来确定表之间的连接关系,得到初步的数据

  - where对数据进行普通的初步的筛选

  - group by 分组

  - 各组分别执行having中的普通筛选或者聚合函数筛选。

  - 然后把再根据我们要的数据进行select,可以是普通字段查询也可以是获取聚合函数的查询结果,如果是集合函数,select的查询结果会新增一条字段

  - 将查询结果去重distinct

  - 最后合并各组的查询结果,按照order by的条件进行排序

![图片](images/640.png)

# 5. 数据库定义语言(DDL)

## 5.1 数据库管理

- ### 查看已有的数据库

  ```mysql
  show databases;
  ```

- ### 创建数据库

  ```mysql
  create database xxx ;
  ```

- ### 删除数据库

  ```mysql
  drop database xxx;
  ```

- ### 进入数据库

  ```mysql
  use xxx;
  ```

## 5.2 数据表管理

- ### 查看当前数据库下所有的数据表

  ```mysql
  show tables;
  ```

- ### 创建表

  ```mysql
  CREATE TABLE 表名称(
  	列名称 类型 NOT NULL  AUTO_INCREAMENT PRIMARY KEY,  --自增,主键（不允许为空,不允许重复）
  	列名称 类型 NOT NULL,  --不允许为空,默认为允许为空
  	列名称 类型 DEFAULT X, --插入数据时不写时,默认值为x
  	列名称 类型
  )DEFAULT CHARSET=utf8;
  ```

- ### 删除表

  ```mysql
  drop table xxx;
  ```

- ### 插入数据

  ```mysql
  INSERT INTO tablexx(key1,key2,...keyn) values(val1,val2,...valn);
  eg:	INSERT INTO user_tbl(name,  age) VALUES('JACK',  18);
      INSERT INTO user_tbl(name,  age) VALUES('ALEX',  19),('Lucy',  17);
  ```

- ### 查看表中所有数据

  ```mysql
  select * from 表名;
  ```

- ### 查看指定表的创建语句

  ```mysql
  show create table xxx;
  ```

- ### 查看表结构

  ```mysql
  desc xxx;
  ```

- ### 修改表结构

  ```mysql
  --修改表添加列
  alter table 表名 add 列名 类型(长度) [约束];
  
  --修改列名和类型
  alter table 表名 change 旧列名 新列名 类型(长度) [约束];
  
  --修改表删除列
  alter table 表名 drop 列名
  
  --修改表名
  rename table 表名 to 新表名
  
  
  ```


## 5.3 数据类型

- ### 数值类型

  | 类型         | 大小                                   | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |
  | ------------ | :------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------- |
  | TINYINT      | 1 Bytes                                | (-128,127)                                                   | (0,255)                                                      | 小整数值        |
  | SMALLINT     | 2 Bytes                                | (-32 768,32 767)                                             | (0,65 535)                                                   | 大整数值        |
  | MEDIUMINT    | 3 Bytes                                | (-8 388 608,8 388 607)                                       | (0,16 777 215)                                               | 大整数值        |
  | INT或INTEGER | 4 Bytes                                | (-2 147 483 648,2 147 483 647)                               | (0,4 294 967 295)                                            | 大整数值        |
  | BIGINT       | 8 Bytes                                | (-9,223,372,036,854,775,808,9 223 372 036 854 775 807)       | (0,18 446 744 073 709 551 615)                               | 极大整数值      |
  | FLOAT        | 4 Bytes                                | (-3.402 823 466 E+38,-1.175 494 351 E-38),0,(1.175 494 351 E-38,3.402 823 466 351 E+38) | 0,(1.175 494 351 E-38,3.402 823 466 E+38)                    | 单精度 浮点数值 |
  | DOUBLE       | 8 Bytes                                | (-1.797 693 134 862 315 7 E+308,-2.225 073 858 507 201 4 E-308),0,(2.225 073 858 507 201 4 E-308,1.797 693 134 862 315 7 E+308) | 0,(2.225 073 858 507 201 4 E-308,1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
  | DECIMAL      | 对DECIMAL(M,D) ,如果M>D,为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |

  其中decimal(M,D) 数字最大位数m:1~65(默认为10) 小数点后的位数D:0~30(不能大于M,默认为0)

  例如：decimal(5,2) 所指代的范围是-999.99~999.99 数字的最大位数是5位,小数点右侧是2位,即有两位小数。

- ### 日期和时间类型

  | 类型      | 大小 ( bytes) | 范围                                                         | 格式                | 用途                    |
  | --------- | ------------- | ------------------------------------------------------------ | ------------------- | ----------------------- |
  | DATE      | 3             | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                  |
  | TIME      | 3             | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间        |
  | YEAR      | 1             | 1901/2155                                                    | YYYY                | 年份值                  |
  | DATETIME  | 8             | 1000-01-01 00:00:00/9999-12-31 23:59:59                      | YYYY-MM-DD HH:MM:SS | 混合日期和时间值        |
  | TIMESTAMP | 4             | 1970-01-01 00:00:00/2038结束时间是第 **2147483647** 秒,北京时间 **2038-1-19 11:14:07**,格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYYMMDD HHMMSS     | 混合日期和时间值,时间戳 |

- ### 字符串类型

  | 类型       | 大小                  | 用途                                                 |
  | ---------- | --------------------- | ---------------------------------------------------- |
  | CHAR       | 0-255 bytes           | 定长字符串,如果插入的长度小于定义长度时,则用空格填充 |
  | VARCHAR    | 0-65535 bytes         | 变长字符串                                           |
  | TINYBLOB   | 0-255 bytes           | 不超过 255 个字符的二进制字符串                      |
  | TINYTEXT   | 0-255 bytes           | 短文本字符串                                         |
  | BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据                               |
  | TEXT       | 0-65 535 bytes        | 长文本数据                                           |
  | MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据                         |
  | MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据                                     |
  | LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据                             |

## 5.4 约束条件

![img](images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p2O5aSn5aSn5aSn5ZOl,size_20,color_FFFFFF,t_70,g_se,x_16.png)

### 5.4.1 主键约束

- 概念

  - MySQL主键约束是一个列或者多个列的组合,其值能唯一地标识表中的每一行,方便在RDBMS(关系型数据库)中尽快的找到某一行

  - 主键约束相当于**唯一约束+非空约束**的组合,主键约束列不允许重复,也不允许出现空值

  - 每个表最多只允许一个主键

  - 主键约束的关键字是：**primary key**

  - 当创建主键的约束时,系统默认会在所在的列和列组合上建立对应的唯一索引

- 操作

  - 添加单列主键

    语法格式：

    ```mysql
    -- 方式1:
    create table 表名(
        ...
    	<字段名> <数据类型> primary key,
        ...
    );
    
    -- 方式2:
    create table 表名(
        ...
        [constraint <约束名>] primary key (字段名)
    );
    ```

  - 添加多列联合主键

    所谓的联合主键,就是这个主键是由一张表中多个字段组成的。

    注意：

    ​	1. 当主键是由多个字段组成时,不能直接在字段名后面声明主键约束。

    ​	2. 一张表只能有一个主键,联合主键也是一个主键

    语法格式：

    ```mysql
    -- 方式1：
    create table 表名(
    	...
        primary key (字段1,  字段2,  ...)
    );
    
    -- 方式2：
    create table 表名(
        ...
        [constraint <约束名>] primary key (字段1,  字段2,  ...)
    );
    ```

    其中,主键不能重复在联合主键上体现为联合主键的每个列全部一样才算重复,主键不能为空在联合主键上体现为每一个列都不能为空。

  - 通过修改表结构添加主键

    语法格式：

    ```mysql
    create table 表名(
    	...
    );
    alter table <表名> add primary key(字段列表);
    ```

  - 删除主键

    语法格式：

    ```mysql
    alter table <表名> drop primary key;
    ```

### 5.4.2 自增长约束

- 概念

  - 在MySQL中,当主键定义为自增长后,这个主键的值就不再需要用户输入数据了,而由数据库系统根据定义自动赋值。每增加一条记录,主键会自动以相同的步长进行增长。


  - 通过给字段添加auto_increment 属性来实现主键自增长

- 语法

  ```mysql
  字段名 数据类型 auto_increment
  ```

- 特点

  - 默认情况下,auto_increment的**初始值是1**,每新增一条记录,字段值自动加1。
  - 一个表中只能有一个字段使用auto_increment约束,且该字段必须有唯一索引,以避免序号重复（即为主键或主键的一部分)。
  - auto increment约束的字段必须具备NOT NULL属性。
  - auto_increment约束的字段只能是整数类型(TINYINT、SMALLINT、INT、BIGINT)等。
  - auto_increment约束字段的最大值受该字段的数据类型约束,如果达到上限,auto_increment就会失效。

- 指定自增字段初始值

  ```mysql
  -- 方式1,创建表时指定：
  create table xxx(
  	id int primary key auto_increment,
  	name varchar(20)
  )auto_increment=20;
  
  -- 方式2,创建表后指定：
  alter table 表名 auto_increment=20;
  ```

- delete和truncate在删除后自增列的变化

  - delete数据之后自动增长从断点开始
  - truncate数据之后自动增长从默认起始值开始

### 5.4.3 唯一约束

- 概念

  唯一约束(unique)是指所有记录中字段的值不能重复出现。

- 语法格式：

  ```mysql
  -- 添加非空约束
  -- 方式1：
  字段名 数据类型 unique;
  
  -- 方式2：
  alter table 表名 add constraint 唯一约束名 unique(列);
  
  -- 删除非空约束
  alter table 表名 drop index <唯一约束名>;  -- 没写约束名默认为列名
  ```

### 5.4.4 非空约束

- 概念

  MySQL非空约束(not null)指字段的值不能为空。对于使用了非空约束的字段,如果用户在添加数据时没有指定值,数据库系统就会报错。

- 语法格式：

  ```mysql
  -- 添加非空约束
  -- 方式1：
  字段名 数据类型 not null;
  
  -- 方式2：
  alter table 表名 modify 字段 类型 not null;
  
  -- 删除非空约束
  alter table 表名 modify 字段 类型;
  ```

### 5.4.5 默认约束

- 概念

  MySQL默认值约束用来指定某列的默认值。

- 语法格式：

  ```mysql
  -- 添加默认约束
  -- 方式1：
  字段名 数据类型 default 默认值;
  
  -- 方式2：
  alter table 表名 modify 字段 类型 default 默认值;
  
  -- 删除默认约束
  alter table 表名 change column 字段 类型 default null;
  ```

### 5.4.6 零填充约束

- 概念

  - 插入数据时,当该字段的值的长度小于定义的长度时,会在该值的前面补上相应的0
  - zerofill默认为int(10)
  - 当使用zerofill时,默认会自动加unsigned(无符号）属性,使用unsigned属性后,数值范围是原值的2倍,例如,有符号为-128~+127,无符号为0~256。

- 语法格式：

  ```mysql
  -- 添加零填充约束
  create table 表名(
  	id int zerofill,  -- 零填充约束
      name varchar(20)
  );
  
  -- 删除零填充约束
  alter table 表名 modify id int;
  ```

## 5.5 外键约束

### 5.5.1 多表关系

MySQL多表之间的关系可以概括为：一对一、一对多/多对一、多对多

- 一对一关系

  - 一个学生只有一张身份证;一张身份证只能对应一学生。
  - 在任一表中添加唯一外键,指向另一方主键,确保一对一关系。
  - 一般一对一关系很少见,遇到一对一关系的表最好是合并表。

- 一对多/多对一关系

  部门和员工
  分析:一个部门有多个员工,一个员工只能对应一个部门

  实现原则:在多的一方建立外键,指向一的一方的主键

- 多对多关系

  学生和课程
  分析:一个学生可以选择很多门课程,一个课程也可以被很多学生选择
  原则:多对多关系实现需要借助第三张中间表。中间表至少包含两个字段,将多对多的关系,拆成一对多的关系,中间表至少要有两个外键,这两个外键分别指向原来的那两张表的主键

### 5.5.2 概念和特点

- 概念

  - MySQL外键约束(FOREIGN KEY)是表的一个特殊字段,经常与主键约束一起使用。
  - 对于两个具有关联关系的表而言,相关联字段中主键所在的表就是主表(父表),外键所在的表就是从表（子表)。

  ![image-20230705142321484](images/image-20230705142321484.png)

- 特点

  定义一个外键时,需要遵守下列规则：

  - 主表必须已经存在于数据库中,或者是当前正在创建的表。
  - 必须为主表定义主键。
  - 主键不能包含空值,但允许在外键中出现空值。也就是说,只要外键的每个非空值出现在指定的主键中,这个外键的内容就是正确的。
  - 在主表的表名后面指定列名或列名的组合。这个列或列的组合必须是主表的主键或候选键。
  - 外键中列的数目必须和主表的主键中列的数目相同。
  - 外键中列的数据类型必须和主表主键中对应列的数据类型相同。

### 5.5.3 创建外键约束

- 创建外键约束的方式

  - **方式1**: 在创建表时设置外键约束

    在create table语句中,通过foreign key关键字来指定外键,具体的语法格式如下:

    ```mysql
    [constraint <外键名>] foreign key 字段名[,字段名2,...] references <主表名> 主键列[,主键列2,...]
    
    -- 创建部门表(主表)
    create table if not exists dept(
    	deptno varchar(20) primary key,   -- 部门号 主键列
        name varchar(20) -- 部门名字
    );
    
    -- 创建员工表(从表)
    create table if not exists emp(
    	eid varchar(20) primary key,  -- 员工编号
        ename varchar(20),  -- 员工名字
        age int,  -- 员工年龄
        dept_id varchar(20),   -- 员工所属部门
        constraint emp_fk foreign key(dept_id) references dept(deptno) 
    );
    ```

  - **方式2:** 在创建表时设置外键约束

    外键约束也可以在修改表时添加,但是添加外键约束的前提是:从表中外键列中的数据必须与主表中主键列中的数据一致或者是没有数据。

    ```mysql
    alter table 表名 add constraint 外键名 foreign key (列名) references 主表名(列名)
    ```

### 5.5.4 外键约束下操作数据

- eg:

  ```mysql
  -- 数据插入
  -- 主表插入不受外键约束
  insert into dept values ( '1001','研发部');
  insert into dept values ( '1002','销售部');
  insert into dept values ( '1003','财务部');
  insert into dept values ( '1004','人事部');
  
  -- 从表的插入受到主表的主键约束
  insert into emp values( '1','乔峰',20,'1001');
  insert into emp values( '2','段誉',21,'1001');
  insert into emp values( '3','虚竹',23,'1001');
  insert into emp values( '4','阿紫',18,'1002');
  insert into emp values( '5','扫地僧',35,'1002');
  insert into emp values( '6','李秋水',33,'1003');
  insert into emp values( '7','鸠摩智',50,'1003');
  insert into emp values( '8','天山童姥',60,'1005');  -- 不可以,因为不存在部门编号为1005的部门
  
  -- 数据删除
  -- 主表的数据被从表依赖时,不能删除,否则可以删除
  -- 从表的数据可以随便删除
  ```

### 5.5.5 删除外键约束

当一个表中不需要外键约束时,就需要从表中将其删除。外键一旦删除,就会解除主表和从表间的关联关系

语法格式：

```mysql
alter table 表名 drop foreign key 外键约束名;
```

### 5.5.6 多对多关系下的外键约束

![image-20230705144737779](images/image-20230705144737779.png)

![image-20230705144852557](images/image-20230705144852557.png)

![image-20230705144859485](images/image-20230705144859485.png)

# 6. 数据库操纵语言(DML)

## 6.1 插入数据

- 语法格式

  ```mysql
  -- 向表中插入一行
  INSERT INTO 表名(列名1,  列名2...) VALUES(值1,  值2...)
  
  -- 向表中所有列插入值
  INSERT INTO 表名 VALUES(值1,  值2,  值3...)
  
  -- 向表中插入多条数据
  INSERT INTO 表名(列名1,  列名2...) VALUES(值1,  值2...),  (值1,  值2...),  (值1,  值2...)...
  ```

## 6.2 修改数据

- 语法格式

  ```mysql
  update 表名 set 列名1=值,  列名2=值 ...
  update 表名 set 列名1=值,  列名2=值 ... where 条件
  ```

## 6.3 删除数据

- 语法格式

  ```mysql
  -- 删除表数据
  delete from 表名 [where 条件]; -- 没有where就是删除表中全部数据
  
  -- 清空表数据
  truncate table 表名 或者 truncate 表名;
  -- delete和truncate原理不同,delete只删除内容,而truncate类似于drop table,可以理解为是将整个表删除,然后再创建该表
  ```

- 两种方式的区别：

  - truncate 是整体删除,delete是逐条删除,所以在删除整个表数据时,truncate比delete快得多

  - truncate不写进服务器的log,  delete会写进服务器的log

  - truncate删除之后,标识列,自增字段,索引重新归1,而delete删除之后,再次添加数据,  会重新会从删掉的索引之后自增。


  - delete更加灵活,可以选择性删除表中数据,delete from '表名' where xxx


  - delete 方式在不带条件的情况下会清空整个表数据,但是自增ID不会还原,而是从删除前最后的ID继续自增。


  - truncate 方式则会将自增ID一同还原为初始值。

# 7. 数据库查询语言(DQL)

## 7.1 单表查询

单表查询是最简单的一种查询,我们只需要在一张表中去查找数据即可,通过使用`select`语句来进行单表查询：

```mysql
-- 指定查询某一列数据
SELECT 列名[,列名] FROM 表名

-- 会以别名显示此列
SELECT 列名 别名 FROM 表名

-- 查询所有的列数据
SELECT * FROM 表名

-- 只查询不重复的值
SELECT DISTINCT 列名 FROM 表名
```

我们也可以添加`where`字句来限定查询目标：

```mysql
SELECT * FROM 表名 WHERE 条件
```

## 7.2 运算符

MySQL支持4种运算符：

- 算术运算符

  | 运算符   | 作用 |
  | -------- | ---- |
  | +        | 加法 |
  | -        | 减法 |
  | *        | 乘法 |
  | / 或 DIV | 除法 |
  | % 或 MOD | 取余 |

- 比较运算符

  | 符号            | 描述                       | 备注                                                         |
  | --------------- | -------------------------- | ------------------------------------------------------------ |
  | =               | 等于                       |                                                              |
  | <>,  !=         | 不等于                     |                                                              |
  | >               | 大于                       |                                                              |
  | <               | 小于                       |                                                              |
  | <=              | 小于等于                   |                                                              |
  | >=              | 大于等于                   |                                                              |
  | BETWEEN AND     | 在两值之间                 | >=min&&<=max                                                 |
  | NOT BETWEEN     | 不在两值之间               |                                                              |
  | IN              | 在集合中                   |                                                              |
  | NOT IN          | 不在集合中                 |                                                              |
  | <=>             | 严格比较两个NULL值是否相等 | 两个操作码均为NULL时,其所得值为1；而当一个操作码为NULL时,其所得值为0 |
  | LIKE            | 模糊匹配                   | %用来匹配任意字符 ,  _匹配单个字符  eg：%x%表示包含x的字符串 x%表示x开头,%x表示x结尾 |
  | REGEXP 或 RLIKE | 正则式匹配                 |                                                              |
  | IS NULL         | 为空                       |                                                              |
  | IS NOT NULL     | 不为空                     |                                                              |

- 逻辑运算符

  | 运算符号 | 作用     |
  | -------- | -------- |
  | NOT 或 ! | 逻辑非   |
  | AND      | 逻辑与   |
  | OR       | 逻辑或   |
  | XOR      | 逻辑异或 |

- 位运算符

  | 运算符号 | 作用     |
  | -------- | -------- |
  | &        | 按位与   |
  | \|       | 按位或   |
  | ^        | 按位异或 |
  | !        | 取反     |
  | <<       | 左移     |
  | >>       | 右移     |

## 7.3 排序查询

我们可以通过`order by`来将查询结果进行排序：

```mysql
SELECT * FROM 表名 WHERE 条件 ORDER BY 列名 ASC|DESC
```

使用ASC表示升序排序,使用DESC表示降序排序,默认为升序。

我们也可以可以同时添加多个排序：

```mysql
SELECT * FROM 表名 WHERE 条件 ORDER BY 列名1 ASC|DESC,  列名2 ASC|DESC
```

这样会先按照列名1进行排序,每组列名1相同的数据再按照列名2排序。

## 7.4 聚合查询

聚合查询使用聚集函数进行查询,聚集函数一般用作统计,包括：

- `count([distinct]*)`统计所有的行数（distinct表示去重再统计,下同）
- `count([distinct]列名)`统计某列的值总和
- `sum([distinct]列名)`求一列的和（注意必须是数字类型的）
- `avg([distinct]列名)`求一列的平均值（注意必须是数字类型）
- `max([distinct]列名)`求一列的最大值
- `min([distinct]列名)`求一列的最小值

一般聚集函数是这样使用的：

```mysql
SELECT count(distinct 列名) FROM 表名 WHERE 条件 
```

## 7.5 分组和分页查询

- 分组查询

  通过使用`group by`来对查询结果进行分组,它需要结合聚合函数一起使用

  分组之后 select的后边只能写分组字段和聚合函数:

  ```mysql
  SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名
  ```

  我们还可以添加`having`来限制分组条件：

  ```mysql
  SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 HAVING 约束条件
  ```

  eg:

  统计各个分类商品的个数,且只显示个数大于4的信息	

  ```mysql
  select category_id,count(*) from product group by category_id having count(*) > 4;
  ```

- 分页查询

  我们可以通过`limit`来限制查询的数量,只取前n个结果：

  ```mysql
  SELECT * FROM 表名 LIMIT n
  ```

  我们也可以进行分页：

  ```mysql
  select 字段1,字段2... from 表名 limit m,n;
  -- m:整数,表示从第几条索引开始,计算方式（当前页-1）*每页显示条数
  -- n:整数,表示查询多少条数据
  ```


## 7.6 多表查询

### 7.6.1 介绍

- 介绍

  多表查询就是同时查询两个或两个以上的表,因为有的时候用户在查看数据的时候,需要显示的数据来自多张表.多表查询有以下分类:

  - ##### 交叉连接查询【产生笛卡尔积,了解】

    语法：

    select * from A,B;

  - ##### 内连接查询(使用的关键字inner join --inner可以省略)

    - 隐式内连接(SQL92标准)

      select * from A,B where 条件;

    - 显示内连接(SQL99标准)

      select * from A inner join B on 条件;

  - ##### 外连接查询(使用的关键字outer join --outer可以省略)

    - 左外连接:left outer join

      select * from A left outer join B on条件;

    - 右外连接: right outer join

      select * from A right outer join B on条件;

    - 满外连接: full outer join

      select * from A full outer join B on条件;

  - ##### 子查询

    select的嵌套

  - ##### 表自关联

    将一张表当成多张表来用

### 7.6.2 交叉连接查询

- 概念

  - 交叉连接查询返回被连接的两个表所有数据行的笛卡尔积

    > 笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时,需要消除无效的笛卡尔积）

  - 笛卡尔积可以理解为一张表的每一行去和另外一张表的任意一行进行匹配

  - 假如A表有m行数据,B表有n行数据,则返回m*n行数据

  - 笛卡尔积会产生很多冗余的数据,后期的其他查询可以在该集合的基础上进行条件筛选

- 语法格式

  ```mysql
  select * from 表1,  表2,...
  ```

- 消除无效的笛卡尔积

  eg:

  ```mysql
  select * from employee,  dept where employee.dept = dept.id;
  ```

  

### 7.6.3 内连接查询

- 概念

  - 内连接查询就是在交叉查询产生的交集基础上增加筛选条件

    ![在这里插入图片描述](images/EDihOjuk8X2t3KW.png)

- 语法格式

  ```mysql
  -- 隐式内连接(SQL92标准)：
  select * from A,B where 条件;
  
  -- 显式内连接(SQL99标准)：
  select * from A inner join B on 条件;
  
  
  -- 查询每个部门的所属员工
  -- 隐式内连接
  select * from dept,emp where dept.deptno = emp.dept_id;
  
  -- 显式内连接
  select * from dept inner join emp on dept.deptno = emp.dept_id;
  ```

### 7.6.4 外连接查询

- 概念

  - 外连接分为左外连接（left outer join)、右外连接(right outer join),满外连接(full outer join)

  - **注意**: oracle里面有full join,可是在mysql对full join支持的不好。我们可以使用union来达到目的。

    - 使用 UNION 还是 UNION ALL ？
      - UNION：会执行去重操作
      - UNION ALL:不会执行去重操作
    - 因此在明确知道数据不存在重复或不需要去重的情况下,尽量使用UNION ALL来提高性能

  - 左外连接示意图,右外连接就是同理反过来

    ![在这里插入图片描述](images/1VYXgZjiBhRrudy.png)

  - 满外连接查询示意图

    满外连接就是 A左外连接B ∪ A右外连接B

    ![image-20230705002938826](images/image-20230705002938826.png)

- 语法格式

  ```mysql
  -- 左外连接:left outer join
  select * from A left outer join B on条件;
  
  -- 右外连接: right outer join
  select * from A right outer join B on条件;
  
  -- 满外连接: full outer join
  select * from A full outer join B on条件;
  
  select * from A left outer join B on条件
  union
  select * from A right outer join B on条件;
  ```

  

### 7.6.5 子查询(嵌套查询)

- 概念

  - 子查询就是指的在一个完整的查询语句之中,嵌套若干个不同功能的小查询,从而一起完成复杂查询的一种编写形式,通俗一点就是包含select嵌套的查询。
  - 我们可以将查询的结果作为另一个查询的条件

  - 特点

    子查询可以返回的数据类型一共分为四种:

    - 单行单列:返回的是一个具体列的内容,可以理解为一个单值数据;
    - 单行多列:返回一行数据中多个列的内容;
    - 多行单列:返回多行记录之中同一列的内容,相当于给出了一个操作范围;
    - 多行多列:查询返回的结果是一张临时表

- 语法格式

  ```mysql
  -- 查询最大年龄的员工信息
  select * from emp where age = (select max(age) from emp);
  
  -- 查询哪个员工的部门号是1001或者1002
  select * from emp where dept_id in (select deptno from dept where name in ('研发部',  '销售部'));
  ```

  

# 8. 数据库控制语言(DCL)

庞大的数据库不可能由一个人来管理,我们需要更多的用户来一起管理整个数据库。

## 8.1 创建用户

我们可以通过`create user`来创建用户：

```mysql
CREATE USER 用户名 identified by 密码;
```

也可以不带密码：

```mysql
CREATE USER 用户名;
```

我们可以通过@来限制用户登录的登录IP地址,`%`表示匹配所有的IP地址,默认使用的就是任意IP地址。

## 8.2 登录用户

首先需要添加一个环境变量,然后我们通过cmd去登陆mysql：

```mysql
login -u 用户名 -p
```

输入密码后即可登陆此用户,我们输入以下命令来看看能否访问所有数据库：

```mysql
show databases;
```

我们发现,虽然此用户能够成功登录,但是并不能查看完整的数据库列表,这是因为此用户还没有权限！

## 8.3 用户授权

我们可以通过使用`grant`来为一个数据库用户进行授权：

```mysql
grant all|权限1,权限2...(列1,...) on 数据库.表 to 用户 [with grant option]
```

其中all代表授予所有权限,当数据库和表为`*`,代表为所有的数据库和表都授权。如果在最后添加了`with grant option`,那么被授权的用户还能将已获得的授权继续授权给其他用户。

我们可以使用`revoke`来收回一个权限：

```mysql
revoke all|权限1,权限2...(列1,...) on 数据库.表 from 用户
```

# 9.视图

## 9.1 介绍

- 概念
  - 视图(view)是一个虚拟表,非真实存在,其本质是根据SQL语句获取动态的数据集,并为其命名,用户使用时只需使用视图名称即可获取结果集,并可以将其当作表来使用。

  - 数据库中只存放了视图的定义,而并没有存放视图中的数据。这些数据存放在原来的表中。

  - 使用视图查询数据时,数据库系统会从原来的表中取出对应的数据。因此,视图中的数据是依赖于原来的表中的数据的。一旦表中的数据发生改变,显示在视图中的数据也会发生改变。

- 作用
  - 简化代码,可以把重复使用的查询封装成视图重复使用,同时可以使复杂的查询易于理解和使用。
  - 安全原因,如果一张表中有很多数据,很多信息不希望让所有人看到,此时可以使用视图视,如:社会保险基金表,可以用视图只显示姓名,地址,而不显示社会保险号和工资数等,可以对不同的用户,设定不同的视图。

## 9.2 创建视图

- 语法格式

  ![image-20230705021242080](images/image-20230705021242080.png)

  ```mysql
  -- 创建视图
  create or replace view view1_emp
  as
  select ename,age from emp;
  
  -- 查看视图
  select * from view1_emp;
  ```

## 9.3 修改视图

- 概念

  - 修改视图是指修改数据库中已存在的表的定义。当基本表的某些字段发生改变时,可以通过修改视图来保持视图和基本表之间一致。
  - MySQL中通过CREATE OR REPLACEVIEW语句和ALTER VIEW语句来修改视图。

- 语法格式

  ```mysql
  alter view 视图名 as select语句
  ```

## 9.4 更新视图

- 概念
  - 某些视图是可更新的。也就是说,可以在UPDATE、DELETE或INSERT等语句中使用它们,以更新基表的内容。
  - 对于可更新的视图,在视图中的行和基表中的行之间必须具有**一对一**的关系。
  - 如果视图包含下述结构中的任何一种,那么它就是不可更新的:
    - 聚合函数(SUM),MIN(),MAX(),COUNT()等)
    - DISTINCT
    - GROUP BY
    - HAVING
    - UNION或UNION ALL
    - 位于选择列表中的子查询
    - JOIN
    - FROM子句中的不可更新视图
    - WHERE子句中的子查询,引用FROM子句中的表。
    - 仅引用文字值(在该情况下,没有要更新的基本表)
- 注意：视图中虽然可以更新数据,但是有很多的限制。一般情况下,最好将视图作为查询数据的虚拟表,而不要通过视图更新数据。因为,使用视图更新数据时,如果没有全面考虑在视图中更新数据的限制,就可能会造成数据更新失败。

## 9.5 删除视图

- 语法格式

  ```mysql
  drop view [if exists] 视图名;
  ```

## 9.6 重命名视图

- 语法格式

  ```mysql
  rename view 视图名 to 新视图名;
  ```

# 10. 索引

## 10.1 介绍

- 概念

  - 索引是帮助 MySQL **高效获取数据**的**数据结构（有序）**。在数据之外,数据库系统还维护着满足特定查找算法的数据结构,这些数据结构以某种方式引用（指向）数据,这样就可以在这些数据结构上实现高级查询算法,这种数据结构就是索引。


- 优缺点

  - 优点
    - 提高数据检索效率,降低数据库的IO成本
    - 通过索引列对数据进行排序,降低数据排序的成本,降低CPU的消耗
  - 缺点
    - 索引列也是要占用空间的
    - 索引大大提高了查询效率,但降低了更新的速度,比如 INSERT、UPDATE、DELETE

- 索引数据结构

  | 索引数据结构        | 描述                                                         |
  | ------------------- | ------------------------------------------------------------ |
  | B+Tree              | 最常见的索引类型,大部分引擎都支持B+树索引                    |
  | Hash                | 底层数据结构是用哈希表实现,只有精确匹配索引列的查询才有效,不支持范围查询 |
  | R-Tree(空间索引)    | 空间索引是 MyISAM 引擎的一个特殊索引类型,主要用于地理空间数据类型,通常使用较少 |
  | Full-Text(全文索引) | 是一种通过建立倒排索引,快速匹配文档的方式,类似于 Lucene,  Solr,  ES |

  | 索引       | InnoDB        | MyISAM | Memory |
  | ---------- | ------------- | ------ | ------ |
  | B+Tree索引 | 支持          | 支持   | 支持   |
  | Hash索引   | 不支持        | 不支持 | 支持   |
  | R-Tree索引 | 不支持        | 支持   | 不支持 |
  | Full-text  | 5.6版本后支持 | 支持   | 不支持 |

- 索引分类

  ![image-20230706010345051](images/image-20230706010345051.png)

  ![img](images/5bcf406399388995676bff0ad5e459b4.png)

## 10.2 索引数据结构

### 10.2.1 B+ Tree

- B+ Tree的发展历程

  - 二叉树

    ![image-20230706004033373](images/image-20230706004033373.png)

  - 红黑树

    二叉树的缺点可以用红黑树来解决：

    ![image-20230706004107875](images/image-20230706004107875.png)

    红黑树也存在大数据量情况下,层级较深,检索速度慢的问题。

  - B-Tree

    为了解决上述问题,可以使用 B-Tree 结构。
    B-Tree (多路平衡查找树) 以一棵最大度数（max-degree,指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key,5个指针）

    ![image-20230706004154942](images/image-20230706004154942.png)

    > B-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68
    > 演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html

  - B+ Tree

    结构图：

    ![image-20230706004308898](images/image-20230706004308898.png)

    > 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html

    与 B-Tree 的区别：

    - 所有的数据都会出现在叶子节点
    - 叶子节点形成一个单向链表

  - MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上,增加一个指向相邻叶子节点的链表指针,就形成了带有顺序指针的 B+Tree,提高区间访问的性能。

    ![image-20230706004439031](images/image-20230706004439031.png)

### 10.2.2 Hash

- 概念

  - 哈希索引就是采用一定的hash算法,将键值换算成新的hash值,映射到对应的槽位上,然后存储在hash表中。

  - 如果两个（或多个）键值,映射到一个相同的槽位上,他们就产生了hash冲突（也称为hash碰撞）,可以通过链表来解决。

    ![image-20230706005654833](images/image-20230706005654833.png)

- 特点：

  - Hash索引只能用于对等比较（=、in）,不支持范围查询（betwwn、>、<、...）
  - 无法利用索引完成排序操作
  - 查询效率高,通常只需要一次检索就可以了,效率通常要高于 B+Tree 索引

## 10.3 索引分类

### 10.3.1 概述

| 分类     | 含义                                                | 特点                    | 关键字   |
| -------- | --------------------------------------------------- | ----------------------- | -------- |
| 主键索引 | 针对于表中主键创建的索引                            | 默认自动创建,只能有一个 | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                    | 可以有多个              | UNIQUE   |
| 普通索引 | 快速定位特定数据                                    | 可以有多个              |          |
| 全文索引 | 全文索引查找的是文本中的关键词,而不是比较索引中的值 | 可以有多个              | FULLTEXT |

在 **InnoDB** 存储引擎中,根据索引的存储形式,又可以分为以下两种：

| 分类                      | 含义                                                      | 特点                |
| ------------------------- | --------------------------------------------------------- | ------------------- |
| 聚集索引(Clustered Index) | 将数据存储与索引放一块,索引结构的叶子节点保存了行数据     | 必须有,而且只有一个 |
| 二级索引(Secondary Index) | 将数据与索引分开存储,索引结构的叶子节点关联的是对应的主键 | 可以存在多个        |

演示图:

**大致流程:**先根据二级索引找到对应的主键,再根据主键去遍历聚集索引找到对应的数据

![image-20230706013524638](images/image-20230706013524638.png)

![image-20230706013536647](images/image-20230706013536647.png)

聚集索引选取规则：

- 如果存在主键,主键索引就是聚集索引
- 如果不存在主键,将使用第一个唯一(UNIQUE)索引作为聚集索引
- 如果表没有主键或没有合适的唯一索引,则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引

思考题:

 以下 SQL 语句,哪个执行效率高？为什么？

```mysql
select * from user where id = 10;
select * from user where name = 'Arm';
-- 备注：id为主键,name字段创建的有索引
```

答：第一条语句,因为第二条需要回表查询,相当于两个步骤。

### 10.3.2 单列索引

#### 10.3.2.1 普通索引

- 概念
  - 单列索引:一个索引只包含单个列,但一个表中可以有多个单列索引;
  - 普通索引:MySQL中基本索引类型,没有什么限制,允许在定义索引的列中插入重复值和宝值,纯粹为了查询数据更快一点。

- 创建索引-语法格式:

  ```mysql
  -- 方式1-创建表时的时候直接指定
  create table xxx(
  	...
      index 索引名(字段名)
  );
  -- 方式2-直接创建
  create index 索引名 on 表名(字段名);
  -- 方式3-修改表结构
  alter table 表名 add index 索引名(字段名);
  ```

- 产看索引-语法格式:

  ```mysql
  -- 1. 查看数据库所有索引
  select * from mysql.'innodb index stats' a where a. 'database name'= '数据库名';
  
  -- 2. 查看表中所有索引
  select * from mysql. 'innodb index stats' a where a. 'database name' = '数据库名' and a.table _name like '%表名%';
  
  -- 3.查看表中所有索引
  show index from 表名;
  ```

- 删除索引-语法格式:

  ```mysql
  drop index 索引名 on 表名;
  alter table 表名 drop index 索引名;
  ```

#### 10.3.2.2 唯一索引

- 概念
  - 唯一索引与前面的普通索引类似,不同的就是:索引列的值必须唯一,但允许有空值。

- 语法格式

  ```mysql
  -- 方式1-创建表时的时候直接指定
  create table xxx(
  	...
      unique 索引名(字段名)
  );
  -- 方式2-直接创建
  create unique index 索引名 on 表名(字段名);
  -- 方式3-修改表结构
  alter table 表名 add unique 索引名(字段名);
  ```

### 10.3.2 组合索引

- 概念

  - 组合索引也叫复合索引,指的是我们在建立索引的时候使用多个字段,例如同时使用身份证和手机号建立索引,同样的可以建立为普通索引或者是唯一索引。
  - 复合索引的使用复合最左原则。

- 语法格式

  ```mysql
  -- 1.创建索引
  create index 索引名 on 表名(字段名1,  字段名2...);
  ```

### 10.3.3 全文索引

- 概念

  - 全文索引的关键字是fulltext

  - 全文索引主要用来查找文本中的关键字,而不是直接与索引中的值相比较,它更像是一个搜索引擎,基于相似度的查询,而不是简单的where语句的参数匹配。

  - 用like + %就可以实现模糊匹配了,为什么还要全文索引? 

    like + %在文本比较少时是合适的,但是对于大量的文本数据检索,是不可想象的。全文索引在大量的数据面前,能比 like + %快N倍,速度不是一个数量级,但是全文索引可能存在精度问题。

- 全文索引的版本、存储引擎、数据类型的支持情况:

  - MySQL 5.6以前的版本,只有MylSAM存储引擎支持全文索引;

  - MySQL 5.6及以后的版本,MylSAM和InnoDB存储引擎均支持全文索引;

  - 只有字段的数据类型为**char、varchar、text及其系列**才可以建全文索引;

  - 在数据量较大时候,先将数据放入一个没有全局索引的表中,然后再用create index创建fultext索引,要比先为一张表建立fulltext然后再将数据写入的速度快很多;

  - 测试或使用全文索引时,要先看一下自己的MySQL版本、存储引擎和数据类型是否支持全文索引。

- 语法格式

  ```mysql
  -- 1. 在创建表时直接创建
  create table xxx(
  	...
      fulltext(字段名)
  );
  
  -- 2. 修改表结构添加全文索引
  alter table 表名 add fulltext 索引名(字段名);
  
  -- 3. 直接添加全文索引
  create fulltext index 索引名 on 表名(字段名);
  
  -- 4. 使用全文索引
  select * from 表名 where match(字段名) against('xxx');
  ```

## 10.4 索引使用规则

### 10.4.1 最左前缀法则

- 最左前缀法则
  - 如果索引了多列（**联合索引**），要遵守最左前缀法则。
  - 最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。

- 案例

  一张表有3个字段col1,col2,col3,三个字段组成了一个联合索引

  - 当`select * from table where col1=xx and col2=xx and col3==xx`

    此时,三个字段都会走索引

  - 当`select * from table where col1=xx and col2=xx`

    此时,两个字段都会走索引

  - 当`select * from table where col1=xx`

    此时,col1会走索引

  **因此,联合索引只要第一个字段存在,索引就不会失效,只不过索引长度不同而已**

  - 当`select * from table where col1=xx and col3==xx`

    此时, col1走索引, 而col3索引失效,因为中间跳过了col2字段

  > 注意:
  >
  > 当`select * from table where col2=xx and col3==xx and col1=xx`
  >
  > 此时,是完全满足最左前缀法则的, 联合索引是生效的
  >
  > 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，与我们编写SQL时，**条件编写的先后顺序无关**

### 10.4.2 范围查询

- 联合索引中，出现范围查询**(>,<, between, like)**，范围查询右侧的列索引失效。

- 案例

  当`select * from table where col1=xx and col2>xx and col3==xx`

  此时,由于col2使用>,因此col3字段索引不生效

- 所以，在业务允许的情况下，**尽可能的使用类似于 >= 或 <= 这类的范围查询**，而**避免使用 > 或 <**

### 10.4.3 索引失效情况

- 索引列运算

  不要在索引列上进行运算操作， 索引将失效

- 字符串不加引号

  字符串类型字段使用时，不加引号，索引将失效

  如果字符串不加单引号，对于查询结果，没什么影响，但是数 据库存在隐式类型转换，索引将失效

- 模糊查询

  如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效

  ```mysql
  explain select * from tb_user where profession like '软件%'; -- 生效
  explain select * from tb_user where profession like '%工程'; -- 失效
  explain select * from tb_user where profession like '%工%'; -- 失效
  ```

  经过上述的测试，我们发现，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字 前面加了%，索引将会失效。

- or连接条件

  用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。

- 数据分布影响

  如果MySQL评估使用索引比全表更慢，则不使用索引。

  MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃 索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不 如走全表扫描来的快，此时索引就会失效。

### 10.4.4 覆盖索引

尽量使用覆盖索引，减少select *。 

那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。

### 10.4.5 前缀索引

当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建 立索引，这样可以大大节约索引空间，从而提高索引效率。

- 语法格式

  ```mysql
  create index idx_xxxx on table_name(column(n)) ;
  ```

  - 示例

     为tb_user表的email字段，建立长度为5的前缀索引。

    ```mysql
    create index idx_email_5 on tb_user(email(5));
    ```

- 前缀长度

  - 可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

    ```mysql
    select count(distinct email) / count(*) from tb_user ;
    select count(distinct substring(email,1,5)) / count(*) from tb_user ;
    ```

- 前缀索引的查询流程

  ![image-20230707073540585](images/image-20230707073540585.png)

  > 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。

### 10.4.6 索引设计原则

- 针对于数据量较大，且查询比较频繁的表建立索引
- 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引
- 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高
- 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引
- 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率
- 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率
- 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询

# 11. 事务

## 11.1 概述

MySQL 事务主要用于处理操作量大,复杂度高的数据。比如说,在人员管理系统中,你删除一个人员,你既需要删除人员的基本资料,也要删除和该人员相关的信息,如信箱,文章等等,这样,这些数据库操作语句就构成一个事务！

- 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。
- 事务处理可以用来维护数据库的完整性,保证成批的 SQL 语句要么全部执行,要么全部不执行。
- 事务用来管理 insert,update,delete 语句

> 在 MySQL 命令行的默认设置下,事务都是自动提交的,即执行 SQL 语句后就会马上执行 COMMIT 操作。
>
> 因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION,或者执行命令 SET AUTOCOMMIT=0,用来禁止使用当前会话的自动提交。

## 11.2 四大特性ACID

- **原子性(Atomicity)：**一个事务（transaction）中的所有操作,要么全部完成,要么全部不完成,不会结束在中间某个环节。事务在执行过程中发生错误,会被回滚（Rollback）到事务开始前的状态,就像这个事务从来没有执行过一样。
- **一致性(Consistency)：**在事务开始之前和事务结束以后,数据库的完整性没有被破坏。事务执行后的状态要么是初始状态(执行失败,回滚了),要么是最终状态(执行成功)
- **隔离性(Isolation)：**数据库允许多个并发事务同时对其数据进行读写和修改的能力,隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别,包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- **持久性Durability)：**事务处理结束后,对数据的修改就是永久的,即便系统故障也不会丢失。

## 11.3 事务控制语句

| 控制语句                     | 作用                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| BEGIN                        | 显式地开启一个事务                                           |
| COMMIT                       | 提交事务,并使已对数据库进行的所有修改成为永久性的            |
| ROLLBACK                     | 回滚会结束用户的事务,并撤销正在进行的所有未提交的修改        |
| SAVEPOINT identifier         | 允许在事务中创建一个保存点,一个事务中可以有多个 SAVEPOINT    |
| RELEASE SAVEPOINT identifier | 删除一个事务的保存点,当没有指定的保存点时,执行该语句会抛出一个异常 |
| ROLLBACK TO identifie        | 把事务回滚到标记点                                           |
| SET TRANSACTION              | 用来设置事务的隔离级别                                       |

eg:

```mysql
-- 关闭自动提交
SET AUTOCOMMIT=0 禁止自动提交
SET AUTOCOMMIT=1 开启自动提交

-- 开启事务
begin;
update account set money = money - 200 where name = 'zhangsan';
update account set money = money + 200 where name = 'lisi';
-- 提交事务
commit;
-- 回滚事务
rollback;
```

## 11.4 事务隔离级别

![image-20230706040647766](images/image-20230706040647766.png)

​					**注意**: Serializable 性能最低,  数据安全性最好；Read uncommitted 性能最高,数据安全性最差

- 脏读：A事务读取到B事务没有提交的数据

  > 张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。
  > 与此同时,
  > 事务B正在读取张三的工资,读取到张三的工资为8000。
  > 随后,
  > 事务A发生异常,而回滚了事务。张三的工资又回滚为5000。
  > 最后,
  > 事务B读取到的张三工资为8000的数据即为脏数据,事务B做了一次脏读。

- 不可重复读：A事务在没有提交事务之前,可看到的数据不一致

  > 在事务A中,读取到张三的工资为5000,操作没有完成,事务还没提交。
  > 与此同时,
  > 事务B把张三的工资改为8000,并提交了事务。
  > 随后,
  > 在事务A中,再次读取张三的工资,此时工资变为8000。在一个事务中前后两次读取的结果并不致,导致了不可重复读。

- 幻读：A事务在提交之前和提交之后看到的数据不一致

  > 目前工资为5000的员工有10人,事务A读取所有工资为5000的人数为10人。
  > 此时,
  > 事务B插入一条工资也为5000的记录。
  > 这是,事务A再次读取工资为5000的员工,记录为11人。此时产生了幻读。

- 不可重复读与幻读的区别

  - 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同, 所不同的是不可重复读查询的都是同一个数据项,而幻读针对的是一批数据整体（比如数据的个数）。

  - 二者描述的则重点不同，不可重复读描述的侧重点是修改操作，而幻读描述的侧重点是添加和删除操作。

    比如此级别的事务正在执行时，另一个事务成功的插入了某条数据，但因为它每次查询的结果都是一样的，所以会导致查询不到这条数据，自己重复插入时又失败（因为唯一约束的原因）。明明在事务中查询不到这条信息，但自己就是插入不进去，这就叫幻读 （Phantom Read）。

# 12. 锁机制

## 12.1 概述

事务的**隔离性**(隔离级别)是由锁来保证的。

并发访问数据的情况分为：

- #### 读-读

  即并发事务相继读取相同的记录，因为没涉及到数据的更改，所以不会有并发安全问题，允许这种情况发生。

- #### 写-写

  即并发事务对相同记录进行修改，会出现**脏写**问题，因为任何一种隔离级别都不允许发生脏写，所以多个未提交的事务对同一个记录修改时需要加锁，保证它们是顺序执行的。

  > 锁内存中的结构，当事务想对某条数据进行更改时，首先会查看该记录有没有与之关联的锁结构，有的话则等待它的事务被提交，锁被释放；反之没有锁则生成锁结构与该记录继续关联。

- #### 写-读或读-写

  即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生**脏读 、不可重复读 、幻读**的问题。可以使用两种方式解决(都离不开锁)：

  - 读写都采用加锁的方式，读写也需要排队执行，性能较差
  - 写操作加锁，读操作利用MVVC多版本并发控制，读取历史记录，性能更高

  > 涉及到写操作时，必须有锁

## 12.2 锁的分类

![img](images/16af53dcac8b4b5b9676f78c21993d7b.png)

## 12.3 操作类型分类

- 共享锁（S锁）：也称**读锁**，允许事务对某些数据进行读取。多个事务的读操作不会相互影响，也不会相互阻塞。

- 排他锁（X锁）：也称**写锁**，允许事务对某些数据进行删除或更新。如果当前操作还没完成，其他事务的S和X锁是会被阻塞的，确保在多个事务中，对同一资源，只有一个事务能写入，并防止其他用户读取正在写入的资源。

  |      | S锁      | X锁    |
  | :--- | :------- | ------ |
  | S锁  | **兼容** | 不兼容 |
  | X锁  | 不兼容   | 不兼容 |

### 12.3.1 锁定读

共享锁称为读锁，但不是读一定获取共享锁。正常情况下，select某一条记录时，只需要获取该记录的**共享锁**。但是，在有些情况下可能select记录时就获取记录的**排他锁**，来禁止别的事务来读取该记录，为此，MySQL提供了两种特殊的select语句：

- **对读取的记录加共享锁**

  ```mysql
  SELECT ... LOCK IN SHARE MODE;
  --或者
  SELECT ... FOR SHARE [NOWAIT|SKIP LOCKED];
  -- 8.0新特性，NOWAIT表示不等待直接报错，
  -- SKIP LOCKED表示立即返回，但返回的结果不包含被锁定的行
  ```

  加S锁，此时允许其他事务读取该记录（给该记录加S锁），但是不允许其他事物给该记录加X锁，需要阻塞等待当前事务提交后获取锁。

  > 单纯的select不会加任何锁，它是快照读

- **对读取的记录加排他锁**

  ```mysql
  SELECT ... FOR UPDATE;
  ```

  该select语句会被视为获取X锁，如果当前事务执行了该语句，会给记录加上X锁，不允许其他事务获取该记录的S锁和X锁。

### 12.3.2 锁定写

写操作一定是要获取排它锁的。

- DELETE操作：底层是先获取X锁，再执行删除操作的。
- UPDATE操作：
  - ①如果不是修改主键且修改后数据占用空间不变，则获取X锁，然后直接修改即可
  - ②如果是修改主键或者是记录修改后占用空间发生变化，则先获取X锁，再删除记录，最后重新插入新的记录
- INSERT操作：新插入记录加不了锁，但MySQL会通过建立隐式锁保护这个新插入的记录不被别的事务访问。

## 12.4 锁的粒度分类

从锁的粒度划分可分为：表锁、全局锁以及行锁（锁的粒度越小并发性越好）。目前只有InnDB支持行锁。

- 表锁:操作时，会锁定整个表。
- 行锁:操作时，会锁定当前操作行。

![image-20230706052153145](images/image-20230706052153145.png)

### 12.4.1 表锁

锁定整张表。表锁又可分为：表级别的S锁和X锁、意向锁、元数据锁、自增锁

- 表级别的S锁和X锁

  MylSAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。InnoDB存储引擎是不会为这个表添加表级别的读锁或者写锁的。

  > 使用SHOW OPEN TABLES WHERE in_use>0;可查看加锁状况

- 意向锁

  假如有事务T1和T2，T1获取了某表中最后一行记录的行锁（S锁），此时T2想加表锁（X锁），这是不允许的（S锁和X锁互斥），但是T2并不知道该表有没有加过行锁，需要一行一行的去检查，直到最后一行，效率非常低。但是如果有意向锁的话，T1获取行锁时，会额外加上表级别的意向锁，告诉其他事务该表已经有人加过锁了。此时T2只需要检查该表上是否有意向锁即可。

  

  意向锁的作用就是加快表锁的检查过程。

  

  意向锁是由存储引擎自己维护的 ，用户无法手动获取，在为数据行加共享/排他锁之前，InooDB会先获取该数据所在表的对应意向锁。意向锁可分为：

  - **意向共享锁（IS）**：事务有意向对表中的某些行加共享锁（S锁），会自动加上意向共享锁

    ```mysql
    -- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。
    SELECT column FROM table ... LOCK IN SHARE MODE;
    ```

  - **意向排他锁（IX）**：事务有意向对表中的某些行加排他锁（X锁），会自动加上意向排它锁

    ```mysql
    -- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
    SELECT column FROM table ... FOR UPDATE;
    ```

    由于InnoDB存储引擎支持的是行级别的锁，因此**意向锁不会阻塞除全表扫描以外的任何请求**，它们的主要目的是为了表示是否有人请求锁定表中的某一行数据。

  | 表级别的S锁 | 表级别的X锁 |        |
  | :---------- | :---------- | ------ |
  | IS          | 兼容        | 不兼容 |
  | IX          | 不兼容      | 不兼容 |

  > 还有一点是**意向锁之间是相互兼容的**，很好理解，一张表可以同时存在多个意向锁（包括排他的和共享的），他们都是来自不同的行锁。

- 自增锁

  表中有自增列时，插入记录会使用到自增锁，一个事务持有自增锁时，其他事务的插入语句会被阻塞。了解即可。

- 元数据锁

  在对某个表执行一些诸如ALTER TABLE 、DROP TABLE这类的DDL语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他事务中对这个表执行DDL语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为元数据锁（英文名： Metadata Locks ，简称 **MDL**）结构来实现的。

  > MDL主要是为了避免DML和DDL冲突，保证读写的正确性。

### 12.4.2 行锁

- **行锁：**锁作用于表中的某一行，只会通过锁限制对某一行的操作（仅InnoDB支持）

表锁的作用范围太广了，如果我们仅仅只是对某一行进行操作，那么大可不必对整个表进行加锁，因此`InnoDB`支持了行锁，我们可以使用以下命令来对某一行进行加锁：

```mysql
-- 添加读锁（共享锁）
select * from ... lock in share mode;

-- 添加写锁（排他锁）
select * from ... for update;
```

- 使用InnoDB的情况下，在执行更新、删除、插入操作时，数据库也会自动为所涉及的行添加写锁（排他锁），直到事务提交时，才会释放锁，执行普通的查询操作时，不会添加任何锁。
- 使用MyISAM的情况下，在执行更新、删除、插入操作时，数据库会对涉及的表添加写锁，在执行查询操作时，数据库会对涉及的表添加读锁。



- #### 记录锁(Record Locks)

  - 记录锁, 仅仅锁住索引记录的一行，在单条索引记录上加锁。
  - Record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。
  - 所以说当一条sql没有走任何索引时，那么将会在每一条聚合索引后面加写锁，这个类似于表锁，但原理上和表锁应该是完全不同的。

- #### 间隙锁(Gap Locks)

  - 间隙锁仅仅锁住一个索引区间（开区间，不包括双端端点）。

  - 在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。

    比如在 1、2中，间隙锁的可能值有 (-∞, 1)，(1, 2)，(2, +∞)，间隙锁可用于**防止幻读**，保证索引间的不会被插入数据。

  - 间隙锁有可能会导致**死锁**:

    事务1和事务2都有某个记录的间隙锁，此时事务2因为插入记录而被阻塞（阻塞原因是事务1的间隙锁），所以事务2需要等待事务1提交，然而事务1试图插入记录，插入的记录在事务2中被间隙锁锁住了，所以事务1会去等待事务2提交，这也就出现了**死锁**，互相持有对方的锁。

    > select必须要加锁（for share、for update）才能解决幻读问题

- #### 临键锁(Next-Key Locks)

  - 有时候我们既想锁住某条记录 ，又想阻止其他事务在该记录前边的间隙插入新记录，所以InnoDB就提出了一种称之为Next-Key Locks的锁 。临键锁是在存储引擎InnoDB、事务级别在可重复读 的情况下使用的数据库锁， InnoDB默认的锁就是Next-Key locks。官方的类型名称为： LOCK_ORDINARY

    > 临键锁 = 记录锁 + 间隙锁, 左开右闭区间

  - 在可重复读隔离级别下**默认加的行锁就是临键锁**，防止幻读。但是有些时候InnoDB会将它优化为记录锁或间隙锁：

    | 场景                                       | 转换                           |
    | ------------------------------------------ | ------------------------------ |
    | 使用唯一索引进行精确匹配，但表中不存在记录 | 自动转换为 Gap Locks           |
    | 使用唯一索引进行精确匹配，且表中存在记录   | 自动转换为 Record Locks        |
    | 使用非唯一索引进行精确匹配                 | 不转换                         |
    | 使用唯一索引进行范围匹配                   | 不转换，但是只锁上界，不锁下界 |

### 12.4.3 全局锁

全局锁就是对整个数据库实例加锁。当你需要让整个库处于只读状态的时候，可以使用这个命令，主要是做**全库逻辑备份**

> 备份时应该锁定整个库，保证数据的完整性。

```mysql
-- 加全局锁的命令：
flush tables with read lock;

-- 解锁
unlock tables;
```

## 12.5 锁的态度分类

分为悲观锁和乐观锁。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的**设计思想** 。

### 12.5.1 悲观锁

- 悲观锁(Pessimistic Locking):假设最坏的情况，每次操作数据都会加上锁，如行锁、表锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

- 案例

  商品秒杀过程中，库存数量的减少，避免出现**超卖**的情况。比如，商品表中有一个字段为quantity表示当前该商品的库存量。如果不使用锁的情况下，操作方法如下所示

  ```mysql
  #1.查出商品库存
  select quantity from items where id=1001;
  
  #2.如果库存大于0，则根据商品信息生成订单
  insert into orders(item_id) values(1001);
  
  #3.修改商品的库存，num表示购买数量
  update items set quantity=quantity-1 where id=1001;
  ```

  高并发可能会产生问题：

  |      | 事务1                | 事务2                   |
  | :--- | :------------------- | ----------------------- |
  | 1    | 查询1001商品库存为1  | 查询1001库存为1         |
  | 2    | 生成订单             | 生成订单                |
  | 3    | 库存减掉1，库存为0了 |                         |
  | 4    | 提交事务             |                         |
  | 5    |                      | 库存减1，为-1了，超卖了 |

  其主要原因是查询时不会加锁，可以同时进行

  **使用悲观锁来解决问题**：当查询库存时就把数据给锁定，保证同时只能有一个事务查询到库存，其他事务必须等他将库存减去后才能查询到库存。

  ```mysql
  #读取时需要获取x锁
  select quantity from items where id=1001 for update;
  
  insert into orders(item_id) values(1001);
  
  update items set quantity=quantity-1 where id=1001;
  ```

  > 注意: select ... for update语句执行过程中所有扫描的行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则将会把整个表锁住。
  >
  > 
  >
  > 另外，也可以在应用程序方面加锁来解决这种问题。

​		**缺点:**悲观锁开销较大，特别是长事务。

### 12.5.2 乐观锁

- 乐观锁(Optimistic Locking)
  - 乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，**它不采用数据库自身的锁机制，而是通过程序来实现**。
  - 在程序上，我们可以采用**版本号机制**或者**CAS机制**实现。**乐观锁适用于多读和冲突不激烈的应用类型，这样可以提高吞吐量**。在Java中通过CAS实现的。

- 乐观锁机制

  - 在表中增加一个**版本字段version**，对数据进行更新时会执行**UPDATE ... SET version=version+1 WHERE version=xx**。如果已经有事务对这条数据进行了更新，则不会成功。

- 案例

  ![img](images/ccef6a65ee2143db8dbbf91da8540021.png)

   其中第二个事务更新失败，应该在程序里再循环执行（查询库存和版本号->更新），第二次发现库存已经为0了，才退出。

## 12.6 死锁

![img](images/fcee4c8258ff438c9ee18a1fea1f252a.png)

当出现死锁以后，有两种策略：

- 直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。
- 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on ，表示开启这个逻辑。

# 11. 存储过程(略过)

[触发器和存储过程 - 一个程序媛芽 - 博客园 (cnblogs.com)](https://www.cnblogs.com/wanyuy/p/17095104.html)

# 12. 触发器(略过)

# 13. 函数

## 13.1 概述

- 概述

  在MySQL中，为了提高代码重用性和隐藏实现细节，MysQL提供了很多函数。函数可以理解为别人封装好的模板代码。

- 分类

  在MySQL中，函数非常多，主要可以分为以下几类:·

  - 聚合函数
  - 数学函数

  - 字符串函数

  - 日期函数
  - 控制流函数
  - 窗口函数

## 13.2 聚合函数

##### 常用的聚合函数和用法

聚合函数是对表中数据记录进行集中概括而设计的一类函数

| 函数名  | 注释                               |
| ------- | ---------------------------------- |
| avg()   | 输出指定列的平均值                 |
| count() | 输出指定列统计到的非NULL的值的个数 |
| min()   | 输出指定列的最小值                 |
| max()   | 输出指定列的最大值                 |
| sum()   | 输出指定列的所有值之和             |

## 13.3 字符串函数

常用字符串函数的用法

| 函数                                  | 描述                                                         | 实例                                                         |
| ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ASCII(s)                              | 返回字符串 s 的第一个字符的 ASCII 码。                       | 返回 CustomerName 字段第一个字母的 ASCII 码：`SELECT ASCII(CustomerName) AS NumCodeOfFirstChar FROM Customers;` |
| CHAR_LENGTH(s)                        | 返回字符串 s 的字符数                                        | 返回字符串 RUNOOB 的字符数`SELECT CHAR_LENGTH("RUNOOB") AS LengthOfString;` |
| CHARACTER_LENGTH(s)                   | 返回字符串 s 的字符数，等同于 CHAR_LENGTH(s)                 | 返回字符串 RUNOOB 的字符数`SELECT CHARACTER_LENGTH("RUNOOB") AS LengthOfString;` |
| CONCAT(s1,s2...sn)                    | 字符串 s1,s2 等多个字符串合并为一个字符串                    | 合并多个字符串`SELECT CONCAT("SQL ", "Runoob ", "Gooogle ", "Facebook") AS ConcatenatedString;` |
| CONCAT_WS(x, s1,s2...sn)              | 同 CONCAT(s1,s2,...) 函数，但是每个字符串之间要加上 x，x 可以是分隔符 | 合并多个字符串，并添加分隔符：`SELECT CONCAT_WS("-", "SQL", "Tutorial", "is", "fun!")AS ConcatenatedString;` |
| FIELD(s,s1,s2...)                     | 返回第一个字符串 s 在字符串列表(s1,s2...)中的位置            | 返回字符串 c 在列表值中的位置：`SELECT FIELD("c", "a", "b", "c", "d", "e");` |
| FIND_IN_SET(s1,s2)                    | 返回在字符串s2中与s1匹配的字符串的位置                       | 返回字符串 c 在指定字符串中的位置：`SELECT FIND_IN_SET("c", "a,b,c,d,e");` |
| FORMAT(x,n)                           | 函数可以将数字 x 进行格式化 "#,###.##", 将 x 保留到小数点后 n 位，最后一位四舍五入。 | 格式化数字 "#,###.##" 形式：`SELECT FORMAT(250500.5634, 2);     -- 输出 250,500.56` |
| INSERT(s1,x,len,s2)                   | 字符串 s2 替换 s1 的 x 位置开始长度为 len 的字符串           | 从字符串第一个位置开始的 6 个字符替换为 runoob：`SELECT INSERT("google.com", 1, 6, "runoob");  -- 输出：runoob.com` |
| LOCATE(s1,s)                          | 从字符串 s 中获取 s1 的开始位置                              | 获取 b 在字符串 abc 中的位置：`SELECT LOCATE('st','myteststring');  -- 5`返回字符串 abc 中 b 的位置：`SELECT LOCATE('b', 'abc') -- 2` |
| LCASE(s)                              | 将字符串 s 的所有字母变成小写字母                            | 字符串 RUNOOB 转换为小写：`SELECT LCASE('RUNOOB') -- runoob` |
| LEFT(s,n)                             | 返回字符串 s 的前 n 个字符                                   | 返回字符串 runoob 中的前两个字符：`SELECT LEFT('runoob',2) -- ru` |
| LOWER(s)                              | 将字符串 s 的所有字母变成小写字母                            | 字符串 RUNOOB 转换为小写：`SELECT LOWER('RUNOOB') -- runoob` |
| LPAD(s1,len,s2)                       | 在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len      | 将字符串 xx 填充到 abc 字符串的开始处：`SELECT LPAD('abc',5,'xx') -- xxabc` |
| LTRIM(s)                              | 去掉字符串 s 开始处的空格                                    | 去掉字符串 RUNOOB开始处的空格：`SELECT LTRIM("    RUNOOB") AS LeftTrimmedString;-- RUNOOB` |
| MID(s,n,len)                          | 从字符串 s 的 n 位置截取长度为 len 的子字符串，同 SUBSTRING(s,n,len) | 从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：`SELECT MID("RUNOOB", 2, 3) AS ExtractString; -- UNO` |
| POSITION(s1 IN s)                     | 从字符串 s 中获取 s1 的开始位置                              | 返回字符串 abc 中 b 的位置：`SELECT POSITION('b' in 'abc') -- 2` |
| REPEAT(s,n)                           | 将字符串 s 重复 n 次                                         | 将字符串 runoob 重复三次：`SELECT REPEAT('runoob',3) -- runoobrunoobrunoob` |
| REPLACE(s,s1,s2)                      | 将字符串 s2 替代字符串 s 中的字符串 s1                       | 将字符串 abc 中的字符 a 替换为字符 x：`SELECT REPLACE('abc','a','x') --xbc` |
| REVERSE(s)                            | 将字符串s的顺序反过来                                        | 将字符串 abc 的顺序反过来：`SELECT REVERSE('abc') -- cba`    |
| RIGHT(s,n)                            | 返回字符串 s 的后 n 个字符                                   | 返回字符串 runoob 的后两个字符：`SELECT RIGHT('runoob',2) -- ob` |
| RPAD(s1,len,s2)                       | 在字符串 s1 的结尾处添加字符串 s2，使字符串的长度达到 len    | 将字符串 xx 填充到 abc 字符串的结尾处：`SELECT RPAD('abc',5,'xx') -- abcxx` |
| RTRIM(s)                              | 去掉字符串 s 结尾处的空格                                    | 去掉字符串 RUNOOB 的末尾空格：`SELECT RTRIM("RUNOOB     ") AS RightTrimmedString;   -- RUNOOB` |
| SPACE(n)                              | 返回 n 个空格                                                | 返回 10 个空格：`SELECT SPACE(10);`                          |
| STRCMP(s1,s2)                         | 比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1>s2 返回 1，如果 s1<s2 返回 -1 | 比较字符串：`SELECT STRCMP("runoob", "runoob");  -- 0`       |
| SUBSTR(s, start, length)              | 从字符串 s 的 start 位置截取长度为 length 的子字符串         | 从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：`SELECT SUBSTR("RUNOOB", 2, 3) AS ExtractString; -- UNO` |
| SUBSTRING(s, start, length)           | 从字符串 s 的 start 位置截取长度为 length 的子字符串，等同于 SUBSTR(s, start, length) | 从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：`SELECT SUBSTRING("RUNOOB", 2, 3) AS ExtractString; -- UNO` |
| SUBSTRING_INDEX(s, delimiter, number) | 返回从字符串 s 的第 number 个出现的分隔符 delimiter 之后的子串。 如果 number 是正数，返回第 number 个字符左边的字符串。 如果 number 是负数，返回第(number 的绝对值(从右边数))个字符右边的字符串。 | `SELECT SUBSTRING_INDEX('a*b','*',1) -- a SELECT SUBSTRING_INDEX('a*b','*',-1)  -- b SELECT SUBSTRING_INDEX(SUBSTRING_INDEX('a*b*c*d*e','*',3),'*',-1)  -- c` |
| TRIM(s)                               | 去掉字符串 s 开始和结尾处的空格                              | 去掉字符串 RUNOOB 的首尾空格：`SELECT TRIM('    RUNOOB    ') AS TrimmedString;` |
| UCASE(s)                              | 将字符串转换为大写                                           | 将字符串 runoob 转换为大写：`SELECT UCASE("runoob"); -- RUNOOB` |
| UPPER(s)                              | 将字符串转换为大写                                           | 将字符串 runoob 转换为大写：`SELECT UPPER("runoob"); -- RUNOOB` |

## 13.4 日期函数

| 函数名                                            | 描述                                                         | 实例                                                         |
| ------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ADDDATE(d,n)                                      | 计算起始日期 d 加上 n 天的日期                               | `SELECT ADDDATE("2017-06-15", INTERVAL 10 DAY); ->2017-06-25` |
| ADDTIME(t,n)                                      | n 是一个时间表达式，时间 t 加上时间表达式 n                  | 加 5 秒：`SELECT ADDTIME('2011-11-11 11:11:11', 5); ->2011-11-11 11:11:16 (秒)`添加 2 小时, 10 分钟, 5 秒:`SELECT ADDTIME("2020-06-15 09:34:21", "2:10:5");  -> 2020-06-15 11:44:26` |
| CURDATE()                                         | 返回当前日期                                                 | `SELECT CURDATE(); -> 2018-09-19`                            |
| CURRENT_DATE()                                    | 返回当前日期                                                 | `SELECT CURRENT_DATE(); -> 2018-09-19`                       |
| CURRENT_TIME                                      | 返回当前时间                                                 | `SELECT CURRENT_TIME(); -> 19:59:02`                         |
| CURRENT_TIMESTAMP()                               | 返回当前日期和时间                                           | `SELECT CURRENT_TIMESTAMP() -> 2018-09-19 20:57:43`          |
| CURTIME()                                         | 返回当前时间                                                 | `SELECT CURTIME(); -> 19:59:02`                              |
| DATE()                                            | 从日期或日期时间表达式中提取日期值                           | `SELECT DATE("2017-06-15");     -> 2017-06-15`               |
| DATEDIFF(d1,d2)                                   | 计算日期 d1->d2 之间相隔的天数                               | `SELECT DATEDIFF('2001-01-01','2001-02-02') -> -32`          |
| DATE_ADD(d，INTERVAL expr type)                   | 计算起始日期 d 加上一个时间段后的日期，type 值可以是：MICROSECONDSECONDMINUTEHOURDAYWEEKMONTHQUARTERYEARSECOND_MICROSECONDMINUTE_MICROSECONDMINUTE_SECONDHOUR_MICROSECONDHOUR_SECONDHOUR_MINUTEDAY_MICROSECONDDAY_SECONDDAY_MINUTEDAY_HOURYEAR_MONTH | `SELECT DATE_ADD("2017-06-15", INTERVAL 10 DAY);     -> 2017-06-25 SELECT DATE_ADD("2017-06-15 09:34:21", INTERVAL 15 MINUTE); -> 2017-06-15 09:49:21 SELECT DATE_ADD("2017-06-15 09:34:21", INTERVAL -3 HOUR); ->2017-06-15 06:34:21 SELECT DATE_ADD("2017-06-15 09:34:21", INTERVAL -3 MONTH); ->2017-04-15` |
| DATE_FORMAT(d,f)                                  | 按表达式 f的要求显示日期 d                                   | `SELECT DATE_FORMAT('2011-11-11 11:11:11','%Y-%m-%d %r') -> 2011-11-11 11:11:11 AM` |
| DATE_SUB(date,INTERVAL expr type)                 | 函数从日期减去指定的时间间隔。                               | Orders 表中 OrderDate 字段减去 2 天：`SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDate FROM Orders` |
| DAY(d)                                            | 返回日期值 d 的日期部分                                      | `SELECT DAY("2017-06-15");   -> 15`                          |
| DAYNAME(d)                                        | 返回日期 d 是星期几，如 Monday,Tuesday                       | `SELECT DAYNAME('2011-11-11 11:11:11') ->Friday`             |
| DAYOFMONTH(d)                                     | 计算日期 d 是本月的第几天                                    | `SELECT DAYOFMONTH('2011-11-11 11:11:11') ->11`              |
| DAYOFWEEK(d)                                      | 日期 d 今天是星期几，1 星期日，2 星期一，以此类推            | `SELECT DAYOFWEEK('2011-11-11 11:11:11') ->6`                |
| DAYOFYEAR(d)                                      | 计算日期 d 是本年的第几天                                    | `SELECT DAYOFYEAR('2011-11-11 11:11:11') ->315`              |
| EXTRACT(type FROM d)                              | 从日期 d 中获取指定的值，type 指定返回的值。 type可取值为： MICROSECONDSECONDMINUTEHOURDAYWEEKMONTHQUARTERYEARSECOND_MICROSECONDMINUTE_MICROSECONDMINUTE_SECONDHOUR_MICROSECONDHOUR_SECONDHOUR_MINUTEDAY_MICROSECONDDAY_SECONDDAY_MINUTEDAY_HOURYEAR_MONTH | `SELECT EXTRACT(MINUTE FROM '2011-11-11 11:11:11')  -> 11`   |
| FROM_DAYS(n)                                      | 计算从 0000 年 1 月 1 日开始 n 天后的日期                    | `SELECT FROM_DAYS(1111) -> 0003-01-16`                       |
| HOUR(t)                                           | 返回 t 中的小时值                                            | `SELECT HOUR('1:2:3') -> 1`                                  |
| LAST_DAY(d)                                       | 返回给给定日期的那一月份的最后一天                           | `SELECT LAST_DAY("2017-06-20"); -> 2017-06-30`               |
| LOCALTIME()                                       | 返回当前日期和时间                                           | `SELECT LOCALTIME() -> 2018-09-19 20:57:43`                  |
| LOCALTIMESTAMP()                                  | 返回当前日期和时间                                           | `SELECT LOCALTIMESTAMP() -> 2018-09-19 20:57:43`             |
| MAKEDATE(year, day-of-year)                       | 基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期 | `SELECT MAKEDATE(2017, 3); -> 2017-01-03`                    |
| MAKETIME(hour, minute, second)                    | 组合时间，参数分别为小时、分钟、秒                           | `SELECT MAKETIME(11, 35, 4); -> 11:35:04`                    |
| MICROSECOND(date)                                 | 返回日期参数所对应的微秒数                                   | `SELECT MICROSECOND("2017-06-20 09:34:00.000023"); -> 23`    |
| MINUTE(t)                                         | 返回 t 中的分钟值                                            | `SELECT MINUTE('1:2:3') -> 2`                                |
| MONTHNAME(d)                                      | 返回日期当中的月份名称，如 November                          | `SELECT MONTHNAME('2011-11-11 11:11:11') -> November`        |
| MONTH(d)                                          | 返回日期d中的月份值，1 到 12                                 | `SELECT MONTH('2011-11-11 11:11:11') ->11`                   |
| NOW()                                             | 返回当前日期和时间                                           | `SELECT NOW() -> 2018-09-19 20:57:43`                        |
| PERIOD_ADD(period, number)                        | 为 年-月 组合日期添加一个时段                                | `SELECT PERIOD_ADD(201703, 5);    -> 201708`                 |
| PERIOD_DIFF(period1, period2)                     | 返回两个时段之间的月份差值                                   | `SELECT PERIOD_DIFF(201710, 201703); -> 7`                   |
| QUARTER(d)                                        | 返回日期d是第几季节，返回 1 到 4                             | `SELECT QUARTER('2011-11-11 11:11:11') -> 4`                 |
| SECOND(t)                                         | 返回 t 中的秒钟值                                            | `SELECT SECOND('1:2:3') -> 3`                                |
| SEC_TO_TIME(s)                                    | 将以秒为单位的时间 s 转换为时分秒的格式                      | `SELECT SEC_TO_TIME(4320) -> 01:12:00`                       |
| STR_TO_DATE(string, format_mask)                  | 将字符串转变为日期                                           | `SELECT STR_TO_DATE("August 10 2017", "%M %d %Y"); -> 2017-08-10` |
| SUBDATE(d,n)                                      | 日期 d 减去 n 天后的日期                                     | `SELECT SUBDATE('2011-11-11 11:11:11', 1) ->2011-11-10 11:11:11 (默认是天)` |
| SUBTIME(t,n)                                      | 时间 t 减去 n 秒的时间                                       | `SELECT SUBTIME('2011-11-11 11:11:11', 5) ->2011-11-11 11:11:06 (秒)` |
| SYSDATE()                                         | 返回当前日期和时间                                           | `SELECT SYSDATE() -> 2018-09-19 20:57:43`                    |
| TIME(expression)                                  | 提取传入表达式的时间部分                                     | `SELECT TIME("19:30:10"); -> 19:30:10`                       |
| TIME_FORMAT(t,f)                                  | 按表达式 f 的要求显示时间 t                                  | `SELECT TIME_FORMAT('11:11:11','%r') 11:11:11 AM`            |
| TIME_TO_SEC(t)                                    | 将时间 t 转换为秒                                            | `SELECT TIME_TO_SEC('1:12:00') -> 4320`                      |
| TIMEDIFF(time1, time2)                            | 计算时间差值                                                 | `mysql> SELECT TIMEDIFF("13:10:11", "13:10:10"); -> 00:00:01 mysql> SELECT TIMEDIFF('2000:01:01 00:00:00',    ->                 '2000:01:01 00:00:00.000001');        -> '-00:00:00.000001' mysql> SELECT TIMEDIFF('2008-12-31 23:59:59.000001',    ->                 '2008-12-30 01:01:01.000002');        -> '46:58:57.999999'` |
| TIMESTAMP(expression, interval)                   | 单个参数时，函数返回日期或日期时间表达式；有2个参数时，将参数加和 | `mysql> SELECT TIMESTAMP("2017-07-23",  "13:10:11"); -> 2017-07-23 13:10:11 mysql> SELECT TIMESTAMP('2003-12-31');        -> '2003-12-31 00:00:00' mysql> SELECT TIMESTAMP('2003-12-31 12:00:00','12:00:00');        -> '2004-01-01 00:00:00'` |
| TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2) | 计算时间差，返回 datetime_expr2 − datetime_expr1 的时间差    | `mysql> SELECT TIMESTAMPDIFF(DAY,'2003-02-01','2003-05-01');   // 计算两个时间相隔多少天        -> 89 mysql> SELECT TIMESTAMPDIFF(MONTH,'2003-02-01','2003-05-01');   // 计算两个时间相隔多少月        -> 3 mysql> SELECT TIMESTAMPDIFF(YEAR,'2002-05-01','2001-01-01');    // 计算两个时间相隔多少年        -> -1 mysql> SELECT TIMESTAMPDIFF(MINUTE,'2003-02-01','2003-05-01 12:05:55');  // 计算两个时间相隔多少分钟        -> 128885` |
| TO_DAYS(d)                                        | 计算日期 d 距离 0000 年 1 月 1 日的天数                      | `SELECT TO_DAYS('0001-01-01 01:01:01') -> 366`               |
| WEEK(d)                                           | 计算日期 d 是本年的第几个星期，范围是 0 到 53                | `SELECT WEEK('2011-11-11 11:11:11') -> 45`                   |
| WEEKDAY(d)                                        | 日期 d 是星期几，0 表示星期一，1 表示星期二                  | `SELECT WEEKDAY("2017-06-15"); -> 3`                         |
| WEEKOFYEAR(d)                                     | 计算日期 d 是本年的第几个星期，范围是 0 到 53                | `SELECT WEEKOFYEAR('2011-11-11 11:11:11') -> 45`             |
| YEAR(d)                                           | 返回年份                                                     | `SELECT YEAR("2017-06-15"); -> 2017`                         |
| YEARWEEK(date, mode)                              | 返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推 | `SELECT YEARWEEK("2017-06-15"); -> 201724`                   |

## 13.5 数学函数

| 函数名                             | 描述                                                         | 实例                                                         |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ABS(x)                             | 返回 x 的绝对值                                              | 返回 -1 的绝对值：`SELECT ABS(-1) -- 返回1`                  |
| ACOS(x)                            | 求 x 的反余弦值（单位为弧度），x 为一个数值                  | `SELECT ACOS(0.25);`                                         |
| ASIN(x)                            | 求反正弦值（单位为弧度），x 为一个数值                       | `SELECT ASIN(0.25);`                                         |
| ATAN(x)                            | 求反正切值（单位为弧度），x 为一个数值                       | `SELECT ATAN(2.5);`                                          |
| ATAN2(n, m)                        | 求反正切值（单位为弧度）                                     | `SELECT ATAN2(-0.8, 2);`                                     |
| AVG(expression)                    | 返回一个表达式的平均值，expression 是一个字段                | 返回 Products 表中Price 字段的平均值：`SELECT AVG(Price) AS AveragePrice FROM Products;` |
| CEIL(x)                            | 返回大于或等于 x 的最小整数                                  | `SELECT CEIL(1.5) -- 返回2`                                  |
| CEILING(x)                         | 返回大于或等于 x 的最小整数                                  | `SELECT CEILING(1.5); -- 返回2`                              |
| COS(x)                             | 求余弦值(参数是弧度)                                         | `SELECT COS(2);`                                             |
| COT(x)                             | 求余切值(参数是弧度)                                         | `SELECT COT(6);`                                             |
| COUNT(expression)                  | 返回查询的记录总数，expression 参数是一个字段或者 * 号       | 返回 Products 表中 products 字段总共有多少条记录：`SELECT COUNT(ProductID) AS NumberOfProducts FROM Products;` |
| DEGREES(x)                         | 将弧度转换为角度                                             | `SELECT DEGREES(3.1415926535898) -- 180`                     |
| n DIV m                            | 整除，n 为被除数，m 为除数                                   | 计算 10 除于 5：`SELECT 10 DIV 5;  -- 2`                     |
| EXP(x)                             | 返回 e 的 x 次方                                             | 计算 e 的三次方：`SELECT EXP(3) -- 20.085536923188`          |
| FLOOR(x)                           | 返回小于或等于 x 的最大整数                                  | 小于或等于 1.5 的整数：`SELECT FLOOR(1.5) -- 返回1`          |
| GREATEST(expr1, expr2, expr3, ...) | 返回列表中的最大值                                           | 返回以下数字列表中的最大值：`SELECT GREATEST(3, 12, 34, 8, 25); -- 34`返回以下字符串列表中的最大值：`SELECT GREATEST("Google", "Runoob", "Apple");   -- Runoob` |
| LEAST(expr1, expr2, expr3, ...)    | 返回列表中的最小值                                           | 返回以下数字列表中的最小值：`SELECT LEAST(3, 12, 34, 8, 25); -- 3`返回以下字符串列表中的最小值：`SELECT LEAST("Google", "Runoob", "Apple");   -- Apple` |
| LN                                 | 返回数字的自然对数，以 e 为底。                              | 返回 2 的自然对数：`SELECT LN(2);  -- 0.6931471805599453`    |
| LOG(x) 或 LOG(base, x)             | 返回自然对数(以 e 为底的对数)，如果带有 base 参数，则 base 为指定带底数。 | `SELECT LOG(20.085536923188) -- 3 SELECT LOG(2, 4); -- 2`    |
| LOG10(x)                           | 返回以 10 为底的对数                                         | `SELECT LOG10(100) -- 2`                                     |
| LOG2(x)                            | 返回以 2 为底的对数                                          | 返回以 2 为底 6 的对数：`SELECT LOG2(6);  -- 2.584962500721156` |
| MAX(expression)                    | 返回字段 expression 中的最大值                               | 返回数据表 Products 中字段 Price 的最大值：`SELECT MAX(Price) AS LargestPrice FROM Products;` |
| MIN(expression)                    | 返回字段 expression 中的最小值                               | 返回数据表 Products 中字段 Price 的最小值：`SELECT MIN(Price) AS MinPrice FROM Products;` |
| MOD(x,y)                           | 返回 x 除以 y 以后的余数                                     | 5 除于 2 的余数：`SELECT MOD(5,2) -- 1`                      |
| PI()                               | 返回圆周率(3.141593）                                        | `SELECT PI() --3.141593`                                     |
| POW(x,y)                           | 返回 x 的 y 次方                                             | 2 的 3 次方：`SELECT POW(2,3) -- 8`                          |
| POWER(x,y)                         | 返回 x 的 y 次方                                             | 2 的 3 次方：`SELECT POWER(2,3) -- 8`                        |
| RADIANS(x)                         | 将角度转换为弧度                                             | 180 度转换为弧度：`SELECT RADIANS(180) -- 3.1415926535898`   |
| RAND()                             | 返回 0 到 1 的随机数                                         | `SELECT RAND() --0.93099315644334`                           |
| ROUND(x)                           | 返回离 x 最近的整数                                          | `SELECT ROUND(1.23456) --1`                                  |
| SIGN(x)                            | 返回 x 的符号，x 是负数、0、正数分别返回 -1、0 和 1          | `SELECT SIGN(-10) -- (-1)`                                   |
| SIN(x)                             | 求正弦值(参数是弧度)                                         | `SELECT SIN(RADIANS(30)) -- 0.5`                             |
| SQRT(x)                            | 返回x的平方根                                                | 25 的平方根：`SELECT SQRT(25) -- 5`                          |
| SUM(expression)                    | 返回指定字段的总和                                           | 计算 OrderDetails 表中字段 Quantity 的总和：`SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails;` |
| TAN(x)                             | 求正切值(参数是弧度)                                         | `SELECT TAN(1.75);  -- -5.52037992250933`                    |
| TRUNCATE(x,y)                      | 返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入） | `SELECT TRUNCATE(1.23456,3) -- 1.234`                        |

# 15. 存储引擎

## 15.1 概述

我们可以大致了解一下以下三种存储引擎：

- **MyISAM：**MySQL5.5之前的默认存储引擎，在插入和查询的情况下性能很高，但是它不支持事务，只能添加表级锁。
- **InnoDB：**MySQL5.5之后的默认存储引擎，它支持ACID事务、行级锁、外键，但是性能比不过MyISAM，更加消耗资源。
- **Memory：**数据都存放在内存中，数据库重启或发生崩溃，表中的数据都将消失。

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是 基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果 没有指定将自动选择默认的存储引擎。

我们可以使用下面的命令来查看MySQL支持的存储引擎：

```mysql
-- 查询建表语句
show create table account;

-- 建表时指定存储引擎
CREATE TABLE 表名(
	...
) ENGINE=INNODB;

-- 查看当前数据库支持的存储引擎
show engines;
```

- #### MySQL体系结构

  ![image-20230707034332602](images/image-20230707034332602.png)

  ![image-20230707034337958](images/image-20230707034337958.png)

## 15.2 InnoDB

- 概念

  InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是**默认**的 MySQL 引擎。

- 特点

  - DML 操作遵循 ACID 模型，支持**事务**
  - **行级锁**，提高并发访问性能
  - 支持**外键**约束，保证数据的完整性和正确性

- 文件

  - xxx.ibd: xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结 构（frm-早期的 、sdi-新版的）、数据和索引。

  - 参数: innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间

    ```mysql
    show variables like 'innodb_file_per_table';
    ```

    ![image-20230707041018407](images/image-20230707041018407.png)

  - 从idb文件提取表结构数据：
    （在cmd运行）
    `ibd2sdi xxx.ibd`

    ![image-20230707041509236](images/image-20230707041509236.png)

- InnoDB 逻辑存储结构

  ![image-20230707041954924](images/image-20230707041954924.png)

  - 表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。
  -  段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。
  -  区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。 
  - 页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。 
  - 行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。

## 15.3 MyISAM

- 概念
  - MyISAM 是 MySQL 早期的默认存储引擎。
- 特点
  - 不支持事务，不支持外键
  - 支持表锁，不支持行锁
  - 访问速度快
- 文件
  - xxx.sdi: 存储表结构信息
  - xxx.MYD: 存储数据
  - xxx.MYI: 存储索引

## 15.4 Memory

- 概念
  - Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。
- 特点
  - 存放在内存中，速度快
  - hash索引（默认）
- 文件
  - xxx.sdi: 存储表结构信息

## 15.5 区别及特点

| 特点         | InnoDB              | MyISAM | Memory |
| ------------ | ------------------- | ------ | ------ |
| 存储限制     | 64TB                | 有     | 有     |
| 事务安全     | 支持                | -      | -      |
| 锁机制       | 行锁                | 表锁   | 表锁   |
| B+tree索引   | 支持                | 支持   | 支持   |
| Hash索引     | -                   | -      | 支持   |
| 全文索引     | 支持（5.6版本之后） | 支持   | -      |
| 空间使用     | 高                  | 低     | N/A    |
| 内存使用     | 高                  | 低     | 中等   |
| 批量插入速度 | 低                  | 高     | 高     |
| 支持外键     | 支持                | -      | -      |

## 15.6 存储引擎选择

在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据 实际情况选择多种存储引擎进行组合。

- InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择
- MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。
- Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性

# 16. SQL优化

## 16.1 性能分析

### 16.1.1 查看执行频率

- 查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次

  ```mysql
  SHOW GLOBAL STATUS LIKE 'Com_______'; 
  -- 或者
  SHOW SESSION STATUS LIKE 'Com_______';
  ```

### 16.1.2 慢查询日志

- 慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。

- MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息

  ```mysql
  # 开启慢查询日志开关
  slow_query_log=1
  
  # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
  long_query_time=2
  ```

- 更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log

- 查看慢查询日志开关状态

  ```mysql
  show variables like 'slow_query_log
  ```

### 16.1.3 profile详情

- show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling 参数，能够看到当前MySQL是否支持profile操作：

  ```mysql
  SELECT @@have_profiling ;
  ```

- 可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在 session/global级别开启profiling：

  ```mysql
  SET profiling = 1;
  ```

- 开关已经打开了，接下来，我们所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去 了。 

  执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：

  ```mysql
  -- 查看每一条SQL的耗时基本情况
  show profiles;
  
  -- 查看指定query_id的SQL语句各个阶段的耗时情况
  show profile for query query_id;
  
  -- 查看指定query_id的SQL语句CPU的使用情况
  show profile cpu for query query_id;
  ```

### 16.1.4 explain

- EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺序。

- 语法:

  ```mysql
  -- 直接在select语句之前加上关键字 explain / desc
  EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;
  ```

- Explain 执行计划中各个字段的含义:

  | 字段         | 含义                                                         |
  | ------------ | ------------------------------------------------------------ |
  | id           | select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。 |
  | select_type  | 表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等 |
  | type         | 表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all |
  | possible_key | 显示可能应用在这张表上的索引，一个或多个。                   |
  | key          | 实际使用的索引，如果为NULL，则没有使用索引。                 |
  | key_len      | 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。 |
  | rows         | MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。 |
  | filtered     | 表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。 |

## 16.2 性能优化

### 16.2.1 插入数据

#### 16.2.1.1 insert

如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。

- 批量插入数据

  ```mysql
   Insert into 表名 values(xxx, xxx,...),(xxx, xxx, ...)....;
  ```

- 手动控制事务

  ```mysql
  start transaction;
  insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
  insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');
  insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry');
  commit;
  ```

- 主键顺序插入，性能要高于乱序插入。

  ```mysql
  主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3
  主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89
  ```

#### 16.2.1.2 大批量插入数据

如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使 用MySQL数据库提供的load指令进行插入。

可以执行如下指令，将数据脚本文件中的数据加载到表结构中：

```mysql
-- 客户端连接服务端时，加上参数 -–local-infile
mysql –-local-infile -u root -p

-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile = 1;

-- 执行load指令将准备好的数据，加载到表结构中
load data local infile '/root/sql1.log' into table tb_user fields terminated by ',' lines terminated by '\n' ;
```

> 主键顺序插入性能高于乱序插入

### 16.2.2 主键优化

在上一小节，我们提到，主键顺序插入的性能是要高于乱序插入的。 这一小节，就来介绍一下具体的 原因，然后再分析一下主键又该如何设计。

#### 16.2.2.1 数据组织方式

在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表 (index organized table IOT)。

![image-20230707054448919](images/image-20230707054448919.png)

行数据，都是存储在聚集索引的叶子节点上的。而我们之前也讲解过InnoDB的逻辑结构图：

![image-20230707054505456](images/image-20230707054505456.png)

 在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K.

 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储 到下一个页中，页与页之间会通过指针连接。

#### 16.2.2.2 页分裂

页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行 溢出)，根据主键排列。

- 主键顺序插入效果

  - 从磁盘中申请页， 主键顺序插入

    ![image-20230707054820133](images/image-20230707054820133.png)

  - 第一个页没有满，继续往第一页插入

    ![image-20230707054915202](images/image-20230707054915202.png)

  - 当第一个页写满之后，再写入第二个页，页与页之间会通过指针连接

    ![image-20230707054933875](images/image-20230707054933875.png)

  - 当第二页写满了，再往第三页写入

    ![image-20230707054952225](images/image-20230707054952225.png)

- 主键乱序插入效果

  - 假如1#,2#页都已经写满了，存放了如图所示的数据

    ![image-20230707055017429](images/image-20230707055017429.png)

  - 此时再插入id为50的记录，我们来看看会发生什么现象

    会再次开启一个页，写入新的页中吗？

    ![image-20230707055053898](images/image-20230707055053898.png)

    **不会**。因为，索引结构的叶子节点是有顺序的(B+ Tree结构)。按照顺序，应该存储在47之后。

    ![image-20230707055129428](images/image-20230707055129428.png)

    但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。

    ![image-20230707055358551](images/image-20230707055358551.png)

    但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。

    ![image-20230707055418276](images/image-20230707055418276.png)

    移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个 页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针。

    ![image-20230707055450970](images/image-20230707055450970.png)

    上述的这种现象，称之为 "页分裂"，是比较耗费性能的操作。

#### 16.2.2.3 页合并

目前表中已有数据的索引结构(叶子节点)如下：

![image-20230707060026841](images/image-20230707060026841.png)

当我们对已有数据进行删除时，具体的效果如下: 当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间 变得允许被其他记录声明使用。

![image-20230707060545824](images/image-20230707060545824.png)

当我们继续删除2#的数据记录

![image-20230707060600913](images/image-20230707060600913.png)

当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前 或后）看看是否可以将两个页合并以优化空间使用。

![image-20230707060623585](images/image-20230707060623585.png)

删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页

![image-20230707060649525](images/image-20230707060649525.png)

这个里面所发生的合并页的这个现象，就称之为 "**页合并**"。

> 知识小贴士：
>
> ​		 MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。

#### 16.2.2.4 索引设计原则

- 满足业务需求的情况下，尽量降低主键的长度。
-  插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。 
- 尽量不要使用UUID做主键或者是其他自然主键，如身份证号。
-  业务操作时，避免对主键的修改。

聚集索引和二级索引示意图

![image-20230707061059960](images/image-20230707061059960.png)

### 16.2.3 order by优化

MySQL的排序，有两种方式： 

- Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。 
- Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要 额外排序，操作效率高。 

对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序 操作时，尽量要优化为 Using index。

- order by优化原则
  - 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则
  - 尽量使用覆盖索引
  - 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）
  - 如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）

### 16.2.4 group by优化

- 在分组操作中，我们需要通过以下两点进行优化，以提升性能：
  - 在分组操作时，可以通过索引来提高效率。 
  - 分组操作时，索引的使用也是满足最左前缀法则的。

如索引为`idx_user_pro_age_stat`，则句式可以是`select ... where profession order by age`，这样也符合最左前缀法则

### 16.2.5 limit优化

在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。

- 效率低的原因

  当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记 录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大

- 优化思路

   一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查 询形式进行优化。

  ```mysql
  -- 此语句耗时很长
  select * from tb_sku limit 9000000, 10;
  
  -- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询
  select id from tb_sku order by id limit 9000000, 10;
  
  -- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit
  -- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);
  
  -- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度
  select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;
  ```

### 16.2.6 count优化

#### 16.2.6.1 概述

```mysql
select count(*) from tb_user ;
```

在之前的测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。

- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个 数，效率很高； 但是如果是带条件的count，MyISAM也慢。
- InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出 来，然后累积计数。

如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数 据库进行,但是如果是带条件的count又比较麻烦了)。

#### 16.2.6.2 count用法

count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。

- 用法: count（*）、count（主键）、count（字段）、count（数字）

| count用法    | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| count(主 键) | InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。 服务层拿到主键后，直接按行进行累加(主键不可能为null) |
| count(字 段) | 没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出 来，返回给服务层，服务层判断是否为null，不为null，计数累加。    有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返 回给服务层，直接按行进行累加。 |
| count(1)     | InnoDB 引擎遍历整张表，但不取值。统计不为NULL 的记录         |
| count(*)     | InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接 按行进行累加。统计所有的记录（包括NULL） |

tips: COUNT(DISTINCT 字段)：统计该"字段"去重且不为NULL 的记录

> 按照效率排序的话，count(字段) < count(主键 id) < count(1) ≈ count(\*)，所以尽 量使用 count(*)。

### 16.2.7 update优化

```mysql
update course set name = 'javaEE' where id = 1 ;
```

当我们在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放。

但是当我们在执行如下SQL时:

```mysql
update course set name = 'SpringBoot' where name = 'PHP' ;
```

当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能 大大降低。

> 原因: InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁 升级为表锁 。

因此update语句条件应尽可能使用索引列

# 17. 日志

## 17.1 错误日志

错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过 程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日 志。

该日志是默认开启的，默认存放目录 /var/log/，默认的日志文件名为 mysqld.log 。查看日志 位置：

```mysql
show variables like '%log_error%';
```

## 17.2 二进制日志

### 17.2.1 介绍

二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但 不包括数据查询（SELECT、SHOW）语句。

- 作用

  - ①. 灾难时的数据恢复；
  - ②. MySQL的主从复制。

- 在MySQL8版本中，默认二进制日志是开启着 的，涉及到的参数如下：

  ```mysql
  show variables like '%log_bin%'
  ```

  - 参数说明： 
    - log_bin_basename：当前数据库服务器的binlog日志的基础名称(前缀)，具体的binlog文 件名需要再该basename的基础上加上编号(编号从000001开始)。 
    - log_bin_index：binlog的索引文件，里面记录了当前服务器关联的binlog文件有哪些。

### 17.2.2 格式

MySQL服务器中提供了多种格式来记录二进制日志，具体格式及特点如下：

| 日志格式  | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| STATEMENT | 基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在 日志文件中。 |
| ROW       | 基于行的日志记录，记录的是每一行的数据变更。（默认）         |
| MIXED     | 混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会 自动切换为ROW进行记录。 |

```mysql
show variables like '%binlog_format%'
```

如果我们需要配置二进制日志的格式，只需要在 /etc/my.cnf 中配置 binlog_format 参数即 可。

### 17.2.3 查看

由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具 mysqlbinlog 来查 看，具体语法：

```bash
mysqlbinlog [ 参数选项 ] logfilename

参数选项：
	-d 指定数据库名称，只列出指定的数据库相关操作。
	-o 忽略掉日志中的前n行命令。
	-v 将行事件(数据变更)重构为SQL语句
	-vv 将行事件(数据变更)重构为SQL语句，并输出注释信息
```

### 17.2.4 删除

对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空 间。可以通过以下几种方式清理日志：

| 指令                                             | 含义                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| reset master                                     | 删除全部 binlog 日志，删除之后，日志编号，将 从 binlog.000001重新开始 |
| purge master logs to 'binlog.*'                  | 删除 * 编号之前的所有日志                                    |
| purge master logs before 'yyyy-mm-dd hh24:mi:ss' | 删除日志为 "yyyy-mm-dd hh24:mi:ss" 之前 产生的所有日志       |

也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除。

```mysql
show variables like '%binlog_expire_logs_seconds%';
```

## 17.3 查询日志

查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下， 查询日志是未开启的。

如果需要开启查询日志，可以修改MySQL的配置文件 /etc/my.cnf 文件，添加如下内容：

```mysql
#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启
general_log=1

#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log
general_log_file=mysql_query.log
```

开启了查询日志之后，在MySQL的数据存放目录，也就是 /var/lib/mysql/ 目录下就会出现 mysql_query.log 文件。之后所有的客户端的增删改查操作都会记录在该日志文件之中，长时间运 行后，该日志文件将会非常大。

## 17.4 慢查询日志

慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志，默认未开启。

long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。 如果需要开启慢查询日志，需要在MySQL的配置文件 /etc/my.cnf 中配置如下参数：

```mysql
#慢查询日志
slow_query_log=1

#执行时间参数
long_query_time=2
```

默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。

可以使用 log_slow_admin_statements和 更改此行为 log_queries_not_using_indexes，如下所 述:

```mysql
#记录执行较慢的管理语句
log_slow_admin_statements =1

#记录执行较慢的未使用索引的语句
log_queries_not_using_indexes = 1
```

> 上述所有的参数配置完成之后，都需要重新启动MySQL服务器才可以生效。

# 18. 主从复制

## 18.1 概述

- 主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这 些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。
-  MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状 复制。

![image-20230708003620176](images/image-20230708003620176.png)

- MySQL 复制的优点主要包含以下三个方面：
  -  主库出现问题，可以快速切换到从库提供服务。
  -  实现读写分离，降低主库的访问压力。
  -  可以在从库中执行备份，以避免备份期间影响主库服务。

## 18.2 原理

MySQL主从复制的核心就是 二进制日志，具体的过程如下:

​	![image-20230708003739101](images/image-20230708003739101.png)

从上图来看，复制分成三步： 

- 1. Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。 
- 2. 从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。 
- 3. slave重做中继日志中的事件，将改变反映它自己的数据。

## 18.3 搭建

### 18.3.1 准备

![image-20230708003903338](images/image-20230708003903338.png)

准备好两台服务器之后，在上述的两台服务器中分别安装好MySQL，并完成基础的初始化准备(安装、 密码配置等操作)工作。 其中：

- 192.168.200.200 作为主服务器master 
- 192.168.200.201 作为从服务器slave

### 18.3.2 主库配置

- 1. 修改配置文件 /etc/my.cnf

     ```bash
     #mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，默认为1
     server-id=1
     
     #是否只读,1 代表只读, 0 代表读写
     read-only=0
     
     #忽略的数据, 指不需要同步的数据库
     #binlog-ignore-db=mysql
     
     #指定同步的数据库
     #binlog-do-db=db01
     ```

- 2. 重启MySQL服务器

     ```bash
     systemctl restart mysqld
     ```

- 3. 登录mysql，创建远程连接的账号，并授予主从复制权限

     ```mysql
     #创建用户，并设置密码，该用户可在任意主机连接该MySQL服务
     CREATE USER 'undokey'@'%' IDENTIFIED WITH mysql_native_password BY 'Root@123456';
     
     #为 'undokey'@'%' 用户分配主从复制权限
     GRANT REPLICATION SLAVE ON *.* TO 'undokey'@'%';
     ```

- 4. 通过指令，查看二进制日志坐标

     ```mysql
     show master status ;
     ```

     ![image-20230708004442580](images/image-20230708004442580.png)

     字段含义说明： 

     - file : 从哪个日志文件开始推送日志文件 
     - position ： 从哪个位置开始推送日志 
     - binlog_ignore_db : 指定不需要同步的数据库

### 18.3.3 从库配置

- 1. 修改配置文件 /etc/my.cnf

     ```bash
     #mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，和主库不一样即可
     server-id=2
     
     #是否只读,1 代表只读, 0 代表读写
     read-only=1
     ```

- 2. 重新启动MySQL服务

     ```mysql
     systemctl restart mysqld
     ```

- 3. 登录mysql，设置主库配置

     ```mysql
     CHANGE REPLICATION SOURCE TO SOURCE_HOST='192.168.200.200', SOURCE_USER='undokey',
     SOURCE_PASSWORD='Root@123456', SOURCE_LOG_FILE='binlog.000004',
     SOURCE_LOG_POS=663;
     ```

     上述是8.0.23中的语法。如果mysql是 8.0.23 之前的版本，执行如下SQL：

     ```mysql
     CHANGE MASTER TO MASTER_HOST='192.168.200.200', MASTER_USER='undokey',
     MASTER_PASSWORD='Root@123456', MASTER_LOG_FILE='binlog.000004',
     MASTER_LOG_POS=663;
     ```

     参数名 含义 8.0.23之前 SOURCE_HOST 主库IP地址 MASTER_HOST SOURCE_USER 连接主库的用户名 MASTER_USER SOURCE_PASSWORD 连接主库的密码 MASTER_PASSWORD SOURCE_LOG_FILE binlog日志文件名 MASTER_LOG_FILE SOURCE_LOG_POS binlog日志文件位置 MASTER_LOG_POS

     | 参数名          | 8.0.23之前      | 含义               |
     | --------------- | --------------- | ------------------ |
     | SOURCE_HOST     | MASTER_HOST     | 主库IP地址         |
     | SOURCE_USER     | MASTER_USER     | 连接主库的用户名   |
     | SOURCE_PASSWORD | MASTER_PASSWORD | 连接主库的密码     |
     | SOURCE_LOG_FILE | MASTER_LOG_FILE | binlog日志文件名   |
     | SOURCE_LOG_POS  | MASTER_LOG_POS  | binlog日志文件位置 |

- 4. 开启同步操作

     ```mysql
     start replica ; #8.0.22之后
     start slave ; #8.0.22之前
     ```

- 5. 查看主从同步状态

     ```mysql
     show replica status ; #8.0.22之后
     
     show slave status ; #8.0.22之前
     ```

     ![image-20230708015755881](images/image-20230708015755881.png)

### 18.3.4 测试

- 1. 在主库 192.168.200.200 上创建数据库、表，并插入数据

     ```mysql
     create database db01;
     use db01;
     create table tb_user(
     id int(11) primary key not null auto_increment,
     name varchar(50) not null,
     sex varchar(1)
     )engine=innodb default charset=utf8mb4;
     insert into tb_user(id,name,sex) values(null,'Tom', '1'),(null,'Trigger','0'),
     (null,'Dawn','1');
     ```

- 2. 在从库 192.168.200.201 中查询数据，验证主从是否同步

# 19. 分库分表

## 19.1 介绍

### 19.1.1 问题分析

![image-20230708025749243](images/image-20230708025749243.png)

随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存 储，存在以下性能瓶颈： 

- IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。 请求数据太多，带宽不够，网络IO瓶颈。 
- CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。 

为了解决上述问题，我们需要对数据库进行分库分表处理。

![image-20230708025933784](images/image-20230708025933784.png)



### 19.1.2 拆分策略

分库分表的形式，主要是两种：垂直拆分和水平拆分。而拆分的粒度，一般又分为分库和分表，所以组 成的拆分策略最终如下

![image-20230708030753142](images/image-20230708030753142.png)

### 19.1.3 垂直拆分

- 垂直分库

  ![image-20230708030816382](images/image-20230708030816382.png)

  垂直分库：以表为依据，根据业务将不同表拆分到不同库中。

  - 特点
    - 每个库的表结构都不一样
    - 每个库的数据也不一样
    - 所有库的并集是全量数据

- 垂直分表

  ![image-20230708030915399](images/image-20230708030915399.png)

  垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中。

  - 特点

    - 每个表的结构都不一样
    - 每个表的数据也不一样,一般通过一列（主键/外键）关联

    - 所有表的并集是全量数据。

### 19.1.4 水平拆分

- 水平分库

  ![image-20230708031035843](images/image-20230708031035843.png)

  水平分库：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。

  - 特点
    - 每个库的表结构都一样
    - 每个库的数据都不一样
    - 所有库的并集是全量数据

- 水平分表

  ![image-20230708031107873](images/image-20230708031107873.png)

  水平分表：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。

  - 特点
    - 每个表的表结构都一样
    - 每个表的数据都不一样
    - 所有表的并集是全量数据

> 在业务系统中，为了缓解磁盘IO及CPU的性能瓶颈，到底是垂直拆分，还是水平拆分；
>
> 具体是分库，还是分表，都需要根据具体的业务需求具体分析。

### 19.1.5 实现技术

- **shardingJDBC**：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言，性能较高

- **MyCat**：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者

  ![image-20230708031329506](images/image-20230708031329506.png)

# 20. 读写分离

## 20.1 介绍

读写分离,简单地说是把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操 作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。 通过MyCat即可轻易实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。	

![image-20230708032108985](images/image-20230708032108985.png)

# 小技巧

在SQL语句之后加上`\G`会将结果的表格形式转换成行文本形式